{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/js/app/app.js","app.js","src/js/app/controller.js","src/js/app/inputText.js","src/js/app/storage.js","src/js/app/template.js","src/js/app/view.js","src/js/autoScroll/scrollPosition.js","src/js/autoScroll/targetMatch.js","src/js/inputReader/fileInputReader.js","src/js/inputReader/textInputReader.js","src/js/main.js","src/js/simtexter/match.js","src/js/simtexter/matchSegment.js","src/js/simtexter/simtexter.js","src/js/simtexter/text.js","src/js/simtexter/token.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","App","namespace","defaults","minMatchLength","id","type","value","ignoreFootnotes","ignoreLetterCase","ignoreNumbers","ignorePunctuation","replaceUmlaut","this","storage","Storage","template","Template","view","View","controller","Controller","./controller.js","./storage.js","./template.js","./view.js",2,"global","maxCharactersPerPage","maxNumberOfPages","inputTexts","InputText","_bindEvents","_updateUI","data","$","window","FileInputReader","SimTexter","TextInputReader","prototype","_alertLongInput","idx","self","nrOfPages","getNumberOfPages","inputMode","mode","message","toLowerCase","join","delay","_computeReadingSpeed","showAlertMessage","bind","newValue","_updateStorage","_compare","file","loadingElem","tabPaneId","_readFile","text","_readText","hideModalPromise","_print","setHTMLOption","_isInputValid","toggleWaitingCursor","simtexter","setTimeout","compare","then","nodes","results","texts","uniqueMatches","createTemplates","showSimilarities","resetScrollbars","clearOutputPanel","minMS","speed","Math","round","isValid","activeTabPaneIds","getActiveTabPaneIds","iTextsLength","inputText","activeTabPaneId","isInputTextValid","undefined","toggleErrorStatus","success","print","when","getItemValueByKey","setFileInput","loading","clearTabPaneTextInput","error","reset","loadingStarted","fileInputReader","readFileInput","cleanedText","setTextInput","toggleCompareBtn","clearTabPaneFileInput","test","isHTML","textInputReader","readTextInput","setItemValueById","key","obj","updateUIOption","../inputReader/fileInputReader.js","../inputReader/textInputReader.js","../simtexter/simtexter.js","./inputText.js",3,"fileName","name",4,"_db","_initialize","_getItemByKey","item","_getItemById","_save","localStorage","store","getItem","JSON","parse","setItem","stringify",5,"createAlertMessage","div","document","createElement","className","innerHTML","createOutputTitles","targets","getElementById","tLength","target","toUpperCase","createPrintDialog","section","setAttribute","createPrintSummary","Date","toUTCString","nrOfCharacters","nrOfWords","createStatistics",6,"$alertsPanel","$compareBtn","$contentWrapper","$file","$htmlOptions","$inputLnk","$inputPanel","$inputPanes","$inputFiles","$inputTexts","$outputPanel","$outputTexts","$outputTextContainers","$outputParagraphs","$printBtn","$settingsSidebar","$settingsSidebarLnk","$settingsSidebarPanes","$spinner","$tooltip","_resetTextInputTabPanes","_updateOutputPanelHeight","_updateAlertsPanelWidth","TargetMatch","event","handler","on","elem","_getId","parseInt","val","originalEvent","wheelDelta","detail","stopPropagation","$elem","delegateTarget","find","currentTarget","hasClass","tooltip","removeClass","remove","container","show","hide","html","placement","trigger","filestyle","buttonName","buttonText","placeholder","size","parents","files","_getIndex","parent","_togglePrintDialog","inputComment1","inputComment2","modal","promise","preventDefault","targetMatch","scrollPosition","getScrollPosition","scroll","prop","eq","lastTabPaneId","relatedTarget","attr","_toggleInputPanel","toggleClass","each","_toggleOutputPanel","tabPaneIds","push","addClass","scrollTop","alertMessage","append","children","nLength","$p","body","_computeOutputPanelHeight","bodyHeight","outerHeight","outputPos","offset","top","outputTopPadding","css","elemPos","posOffset","tokens","split","$printDialog","marginLR","navWidth","width","navLeftWidth","outerWidth","navRightWidth","maxWidth","left","max-width","h","../autoScroll/targetMatch.js",7,"ScrollPosition","topPadding","bottomPadding","yPosition",8,"$srcElem","$srcParent","$wrapper","$container","$parent","parentHeight","getBoundingClientRect","height","containerTBPadding","wrapperTopPadding","parseFloat","wrapperBottomPadding","wrapperBottom","yPosDiff","yScrollPos","bottomOffset","abs","topOffset","animate","padding-top","padding-bottom","./scrollPosition.js",9,"JSZip","fileType","_getFileType","deferred","Deferred","fr","FileReader","onerror","NOT_FOUND_ERR","reject","NOT_READABLE_ERR","ABORT_ERR","onloadstart","onload","docxText","_readDOCX","result","resolve","readAsArrayBuffer","odtText","_readODT","txtText","crCleanedText","replace","readAsText","_extractTextFromNode","node","tSelector","brSelector","delimeters","w:p","text:p","p","delimeter","nodeName","str","hasChildNodes","child","firstChild","textContent","nextSibling","_getTextContent","nodeContent","fileContents","xmlDoc","zip","footnotes","parseXML","asText","pNodes","fNodes","fNodesText","eNodes","eNodesText",10,"XRegExp","textNode","letterRegex","isValidNode","skipNodes","skipNodesLength","nodeType","content","extractedContent",11,"load","./app/app.js",12,"Match","srcTxtIdx","srcTkBeginPos","trgTxtIdx","trgTkBeginPos","matchLength",13,"MatchSegment","txtIdx","tkBeginPos","styleClass","createLinkNode","trgMatchSegment","matchLink","href","getTkEndPosition","getTxtBeginPos","txtBeginPos","getTxtEndPos","txtEndPos","setStyleClass",14,"Token","Text","forwardReferences","similarities","_readInput","_getSimilarities","_getNodes","_applyStyles","matches","sortedMatches","_sortSimilarities","sortedMatchesLength","styleClassCnt","uniqueMatch","aUniqueMatches","lastUniqueMatch","match","_buildRegex","NUMBERS","PUNCTUATION","regex","_cleanInputText","langRegex","_cleanWord","word","umlautRules","ä","ö","ü","ß","æ","œ","Ä","Ö","Ü","Æ","Œ","token","_getBestMatch","frwReferences","bestMatch","bestMatchTkPos","bestMatchLength","srcTkPos","trgTkPos","tkPos","tkEndPos","cnt","newMatchLength","styledMatches","chIdx","chIdxLast","chEndPos","mIdx","trgIdxRef","lastTextNodeStr","slice","lastTextNode","createTextNode","mTxtBeginPos","mTxtEndPos","textNodeStr","linkNodeStr","linkNode","srcTkEndPos","_makeForwardReferences","mtsTags","tag","map","mtsHashTable","iLength","_tokenizeInput","sortedSims","sort","b","pos","wordRegex","exec","index","./match.js","./matchSegment.js","./text.js","./token.js",15,16],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,GCCA,YAaA,SAAAK,GAAAC,GAEA,GAAAC,IACAC,gBAAAC,GAAA,oBAAAC,KAAA,YAAAC,MAAA,GACAC,iBAAAH,GAAA,oBAAAC,KAAA,WAAAC,OAAA,GACAE,kBAAAJ,GAAA,sBAAAC,KAAA,WAAAC,OAAA,GACAG,eAAAL,GAAA,kBAAAC,KAAA,WAAAC,OAAA,GACAI,mBAAAN,GAAA,sBAAAC,KAAA,WAAAC,OAAA,GACAK,eAAAP,GAAA,kBAAAC,KAAA,WAAAC,OAAA,GAGAM,MAAAC,QAAA,GAAAC,GAAAb,EAAAC,GACAU,KAAAG,SAAA,GAAAC,GACAJ,KAAAK,KAAA,GAAAC,GAAAN,KAAAG,UACAH,KAAAO,WAAA,GAAAC,GAAAR,KAAAC,QAAAD,KAAAK,MAzBA,GAAAG,GAAA/B,EAAA,mBACAyB,EAAAzB,EAAA,gBACA2B,EAAA3B,EAAA,iBACA6B,EAAA7B,EAAA,YAyBAU,GAAAJ,QAAAK,ICEGqB,kBAAkB,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,YAAY,IAAIC,GAAG,SAASpC,EAAQU,EAAOJ,IACrG,SAAW+B,GCjCX,YAiBA,SAAAN,GAAAP,EAAAI,GACAL,KAAAC,QAAAA,EACAD,KAAAK,KAAAA,EACAL,KAAAe,qBAAA,KACAf,KAAAgB,iBAAA,IACAhB,KAAAiB,YAAA,GAAAC,GAAA,GAAAA,IAEAlB,KAAAmB,cACAnB,KAAAoB,UAAApB,KAAAC,QAAAoB,MAvBA,GAAAC,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACAU,EAAA/C,EAAA,qCACAyC,EAAAzC,EAAA,kBACAgD,EAAAhD,EAAA,6BACAiD,EAAAjD,EAAA,oCA4BA+B,GAAAmB,UAAAC,gBAAA,SAAAC,GACA,GAAAC,GAAA9B,KAGA+B,EAAAD,EAAAb,WAAAY,GAAAG,iBAAAF,EAAAf,qBAEA,IAAAgB,EAAAD,EAAAd,iBAAA,CACA,GAAAiB,GAAAH,EAAAb,WAAAY,GAAAK,KACAC,GACAF,EAAA,IAAAJ,EAAA,EAAA,kFAAAI,EAAAG,cAAA,KACAC,KAAA,IACAC,EAAAR,EAAAS,qBAAAJ,EACAL,GAAAzB,KAAAmC,iBAAA,UAAAL,EAAAG,KASA9B,EAAAmB,UAAAR,YAAA,WACA,GAAAW,GAAA9B,IAEA8B,GAAAzB,KAAAoC,KAAA,qBAAA,SAAAjD,EAAAkD,GACAZ,EAAAa,eAAAnD,EAAAkD,KAGAZ,EAAAzB,KAAAoC,KAAA,UAAA,WACAX,EAAAc,aAGAd,EAAAzB,KAAAoC,KAAA,gBACAX,EAAAzB,KAAAoC,KAAA,mBACAX,EAAAzB,KAAAoC,KAAA,iBAEAX,EAAAzB,KAAAoC,KAAA,YAAA,SAAAI,EAAAhB,EAAAiB,EAAAC,GACAjB,EAAAkB,UAAAH,EAAAhB,EAAAiB,EAAAC,KAGAjB,EAAAzB,KAAAoC,KAAA,YAAA,SAAAQ,EAAApB,EAAAkB,GACAjB,EAAAoB,UAAAD,EAAApB,EAAAkB,KAGAjB,EAAAzB,KAAAoC,KAAA,QAAA,SAAAU,GACArB,EAAAsB,OAAAD,KAGArB,EAAAzB,KAAAoC,KAAA,UACAX,EAAAzB,KAAAoC,KAAA,iBACAX,EAAAzB,KAAAoC,KAAA,aAEAX,EAAAzB,KAAAoC,KAAA,mBAAA,SAAAZ,EAAAa,EAAAO,GACAnB,EAAAb,WAAAY,GAAAwB,cAAAX,GACAO,GACAnB,EAAAoB,UAAAD,EAAApB,EAAAC,EAAAb,WAAAY,GAAAkB,aAIAjB,EAAAzB,KAAAoC,KAAA,uBAAA,SAAAjD,EAAAkD,GACAZ,EAAAa,eAAAnD,EAAAkD,KAGAZ,EAAAzB,KAAAoC,KAAA,mBACAX,EAAAzB,KAAAoC,KAAA,oBACAX,EAAAzB,KAAAoC,KAAA,yBACAX,EAAAzB,KAAAoC,KAAA,+BAQAjC,EAAAmB,UAAAiB,SAAA,WACA,GAAAd,GAAA9B,IAEA,IAAA8B,EAAAwB,gBAAA,CACAxB,EAAAzB,KAAAkD,oBAAA,OACA,IAAAC,GAAA,GAAA/B,GAAAK,EAAA7B,QAEAwD,YAAA,WACAD,EAAAE,QAAA5B,EAAAb,YAAA0C,KAEA,SAAAC,GACA9B,EAAAzB,KAAAwD,SACAC,MAAAN,EAAAM,MACAC,cAAAP,EAAAO,eAGAjC,EAAAzB,KAAA2D,kBACAlC,EAAAzB,KAAA4D,iBAAAL,GACA9B,EAAAzB,KAAA6D,mBAGA,SAAA/B,GACAL,EAAAzB,KAAA8D,kBACA,IAAA7B,GAAAR,EAAAS,qBAAAJ,EACAL,GAAAzB,KAAAmC,iBAAA,OAAAL,EAAAG,MAGA,OAWA9B,EAAAmB,UAAAY,qBAAA,SAAAJ,GACA,GAAAiC,GAAA,IACAC,EAAA,IAAAC,KAAAC,MAAApC,EAAAlD,OAAA,GACA,OAAAoF,GAAAD,EAAAC,EAAAD,GAWA5D,EAAAmB,UAAA2B,cAAA,WAMA,IAAA,GALAxB,GAAA9B,KACAwE,GAAA,EACAC,EAAA3C,EAAAzB,KAAAqE,sBACAC,EAAA7C,EAAAb,WAAAhC,OAEAP,EAAA,EAAAiG,EAAAjG,EAAAA,IAAA,CACA,GAAAkG,GAAA9C,EAAAb,WAAAvC,GACAmG,EAAAJ,EAAA/F,GAEAoG,EAAAC,SAAAH,EAAA3B,MAAA2B,EAAA7B,YAAA8B,CAEAC,GAGAhD,EAAAzB,KAAA2E,kBAAA,OAAAH,GAFA/C,EAAAzB,KAAA2E,kBAAA,OAAAH,GAKAL,EAAAA,GAAAM,EAGA,MAAAN,IAaAhE,EAAAmB,UAAAyB,OAAA,SAAAD,GACA,GAAA8B,GAAA,WACAxB,WAAA,WACAlC,OAAA2D,SACA,KAGA5D,GAAA6D,KAAAhC,GAAAQ,KAAAsB,IAiBAzE,EAAAmB,UAAAqB,UAAA,SAAAH,EAAAhB,EAAAiB,EAAAC,GACA,GAAAjB,GAAA9B,KACAL,EAAAmC,EAAA7B,QAAAmF,kBAAA,mBAEAH,EAAA,SAAAhC,GAEAnB,EAAAb,WAAAY,GAAAwD,aAAAxC,EAAAI,EAAAF,GACAjB,EAAAzB,KAAAiF,QAAA,OAAAxC,GACAhB,EAAAzB,KAAAkF,sBAAA1D,GACAC,EAAAF,gBAAAC,IAGA2D,EAAA,SAAArD,GACAL,EAAAb,WAAAY,GAAA4D,QACA3D,EAAAzB,KAAAiF,QAAA,QAAAxC,GACAhB,EAAAzB,KAAAkF,sBAAA1D,EAEA,IAAAS,GAAAR,EAAAS,qBAAAJ,EACAL,GAAAzB,KAAAmC,iBAAA,QAAAL,EAAAG,GAGA,IAAAO,EAAA,CACA,GAAA6C,GAAA5D,EAAAzB,KAAAiF,QAAA,QAAAxC,GACA6C,EAAA,GAAAnE,GAAAqB,EAAAlD,EACAgG,GAAAC,cAAAF,GAAA/B,KAAAsB,EAAAO,OAEA1D,GAAAzB,KAAAiF,QAAA,SAAAxC,GACAhB,EAAAb,WAAAY,GAAA4D,SAgBAjF,EAAAmB,UAAAuB,UAAA,SAAAD,EAAApB,EAAAkB,GACA,GAAAjB,GAAA9B,KAEAiF,EAAA,SAAAY,GAEA/D,EAAAb,WAAAY,GAAAiE,aAAAD,EAAA9C,GACAjB,EAAAzB,KAAA0F,iBAAA,UACAjE,EAAAzB,KAAA2F,sBAAAnE,GACAC,EAAAF,gBAAAC,IAGA2D,EAAA,SAAArD,GACAL,EAAAb,WAAAY,GAAA4D,QACA3D,EAAAzB,KAAA0F,iBAAA,SACA,IAAAzD,GAAAR,EAAAS,qBAAAJ,EACAL,GAAAzB,KAAAmC,iBAAA,QAAAL,EAAAG,GAGA,IAAAW,EAAAhE,OAAA,GAAA,KAAAgH,KAAAhD,GACA,GAAAnB,EAAAb,WAAAY,GAAAqE,OAAA,CACApE,EAAAzB,KAAA0F,iBAAA,UACA,IAAAI,GAAA,GAAAzE,EACAyE,GAAAC,cAAAnD,GAAAU,KAAAsB,EAAAO,OAEAP,GAAAhC,OAGAnB,GAAAb,WAAAY,GAAA4D,SAWAjF,EAAAmB,UAAAgB,eAAA,SAAAnD,EAAAkD,GACA,GAAAZ,GAAA9B,IACA8B,GAAA7B,QAAAoG,iBAAA7G,EAAAkD,IAUAlC,EAAAmB,UAAAP,UAAA,SAAAC,GACA,GAAAS,GAAA9B,IAEA,KAAA,GAAAsG,KAAAjF,GAAA,CACA,GAAAkF,GAAAlF,EAAAiF,EACAxE,GAAAzB,KAAAmG,eAAAD,EAAA/G,GAAA+G,EAAA9G,KAAA8G,EAAA7G,SAIAP,EAAAJ,QAAAyB,IDoCGxB,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,aAExHkF,oCAAoC,EAAEC,oCAAoC,GAAGC,4BAA4B,GAAGC,iBAAiB,IAAIC,GAAG,SAASpI,EAAQU,EAAOJ,GEtW/J,YAYA,SAAAmC,GAAAgB,EAAAW,EAAAI,EAAAF,GACA/C,KAAA+C,UAAAA,EACA/C,KAAAkC,KAAAA,EACAlC,KAAAkG,QAAA,EACAlG,KAAA8G,SAAAjE,GAAAA,EAAAkE,KACA/G,KAAAiD,KAAAA,EAUA/B,EAAAS,UAAAK,iBAAA,SAAAjB,GACA,MAAAf,MAAAiD,KAAAhE,OAAA8B,GAOAG,EAAAS,UAAA8D,MAAA,WACAzF,KAAA+C,UAAAgC,OACA/E,KAAAkC,KAAA6C,OACA/E,KAAA8G,SAAA/B,OACA/E,KAAAiD,KAAA8B,QAUA7D,EAAAS,UAAA0D,aAAA,SAAAxC,EAAAI,EAAAF,GACA/C,KAAA+C,UAAAA,EACA/C,KAAAkC,KAAA,OACAlC,KAAA8G,SAAAjE,EAAAkE,KACA/G,KAAAiD,KAAAA,GASA/B,EAAAS,UAAAmE,aAAA,SAAA7C,EAAAF,GACA/C,KAAA+C,UAAAA,EACA/C,KAAAkC,KAAA,OACAlC,KAAA8G,SAAA9G,KAAA,OAAA,kBAAA,mBACAA,KAAAiD,KAAAA,GAGA/B,EAAAS,UAAA0B,cAAA,SAAAX,GACA1C,KAAAkG,OAAAxD,GAGAvD,EAAAJ,QAAAmC,OFyWM8F,GAAG,SAASvI,EAAQU,EAAOJ,GGlbjC,YAeA,SAAAmB,GAAAb,EAAAgC,GACArB,KAAAiH,IAAA5H,EACAW,KAAAqB,KAAArB,KAAAkH,YAAA7H,EAAAgC,GAQAnB,EAAAyB,UAAAyD,kBAAA,SAAAkB,GACA,GAAAxE,GAAA9B,IACA,OAAA8B,GAAAqF,cAAAb,GAAA5G,OASAQ,EAAAyB,UAAA0E,iBAAA,SAAA7G,EAAAkD,GACA,GAAAZ,GAAA9B,KACAoH,EAAAtF,EAAAuF,aAAA7H,EAEA4H,GAAA1H,MAAAgD,EACAZ,EAAAwF,MAAAxF,EAAAT,OASAnB,EAAAyB,UAAA0F,aAAA,SAAA7H,GACA,GAAAsC,GAAA9B,KACAqB,EAAAS,EAAAT,IAEA,KAAA,GAAAiF,KAAAjF,GAAA,CACA,GAAAkF,GAAAlF,EAAAiF,EACA,IAAAC,EAAA/G,KAAAA,EACA,MAAA+G,KAaArG,EAAAyB,UAAAwF,cAAA,SAAAb,GACA,GAAAxE,GAAA9B,IACA,OAAA8B,GAAAT,KAAAiF,IAaApG,EAAAyB,UAAAuF,YAAA,SAAA7H,EAAAgC,GACA,GAAAkG,aAAA,CACA,GAAAA,aAAAlI,GAEA,CACA,GAAAmI,GAAAD,aAAAE,QAAApI,EACA,OAAAqI,MAAAC,MAAAH,GAHAD,aAAAK,QAAAvI,EAAAqI,KAAAG,UAAAxG,IAOA,MAAAA,IASAnB,EAAAyB,UAAA2F,MAAA,SAAAjG,GACAkG,cAAAA,aAAAvH,KAAAiH,MACAM,aAAAK,QAAA5H,KAAAiH,IAAAS,KAAAG,UAAAxG,IAEArB,KAAAqB,KAAAA,GAGAlC,EAAAJ,QAAAmB,OHsbM4H,GAAG,SAASrJ,EAAQU,EAAOJ,GIriBjC,YAQA,SAAAqB,MAWAA,EAAAuB,UAAAoG,mBAAA,SAAAtI,EAAA0C,GACA,GAAA6F,GAAAC,SAAAC,cAAA,MAiBA,OAfAF,GAAAG,UAAA,sBACAH,EAAAI,WACA,wCACA,UACA,OACA,+DACA,OACA,OAAA3I,EAAA,QACA,MAAA0C,EAAA,OACA,QACA,QACA,WACA,YACAE,KAAA,IAEA2F,GAQA5H,EAAAuB,UAAA0G,mBAAA,SAAAvE,GAIA,IAAA,GAHAwE,IAAAL,SAAAM,eAAA,kBAAAN,SAAAM,eAAA,mBACAC,EAAAF,EAAArJ,OAEAP,EAAA,EAAA8J,EAAA9J,EAAAA,IAAA,CACA,GAAAoI,GAAAhD,EAAApF,GAAAoI,UAAA,GACA5E,EAAA4B,EAAApF,GAAAuD,UACAwG,EAAAH,EAAA5J,EACA+J,GAAAL,WACA,SAAAlG,EAAAwG,cAAA,SAAA5B,EAAA,SACAzE,KAAA,MAYAjC,EAAAuB,UAAAgH,kBAAA,SAAA7E,GACA,GAAA8E,GAAAX,SAAAC,cAAA,UAuCA,OArCAU,GAAApJ,GAAA,cACAoJ,EAAAT,UAAA,aACAS,EAAAC,aAAA,WAAA,MACAD,EAAAC,aAAA,OAAA,UACAD,EAAAR,WACA,6BACA,8BACA,6BACA,+EACA,0CACA,YACA,4CACA,SACA,2BACA,oBACA,yBACA,yCACA,+CAAAtE,EAAA,GAAA7B,UAAA,WACA,2HACA,SACA,SACA,yBACA,yCACA,+CAAA6B,EAAA,GAAA7B,UAAA,WACA,2HACA,SACA,SACA,SACA,SACA,6BACA,4FACA,2FACA,SACA,SACA,UACAI,KAAA,IAEAuG,GAWAxI,EAAAuB,UAAAmH,mBAAA,SAAAhF,EAAAC,GACA,GAAA0E,GAAAR,SAAAM,eAAA,gBAEAE,GAAAL,WACA,8BACA,mBAAA,GAAAW,OAAAC,cAAA,QACA,uDACA,UACA,OACA,6BACA,wBAAAlF,EAAA,GAAAgD,SAAA,QACA,wBAAAhD,EAAA,GAAAgD,SAAA,QACA,QACA,WACA,UACA,OACA,mBACA,iCACA,iCACA,QACA,OACA,gBACA,OAAAhD,EAAA,GAAA7B,UAAA,QACA,OAAA6B,EAAA,GAAA7B,UAAA,QACA,QACA,OACA,sBACA,OAAA6B,EAAA,GAAAmF,eAAA,QACA,OAAAnF,EAAA,GAAAmF,eAAA,QACA,QACA,OACA,iBACA,OAAAnF,EAAA,GAAAoF,UAAA,QACA,OAAApF,EAAA,GAAAoF,UAAA,QACA,QACA,OACA,0BACA,mBAAAnF,EAAA,QACA,QACA,WACA,YACA1B,KAAA,KAWAjC,EAAAuB,UAAAwH,iBAAA,SAAArF,EAAAC,GACA,GAAA0E,GAAAR,SAAAM,eAAA,aAEAE,GAAAL,WACA,uDACA,UACA,OACA,6BACA,wBAAAtE,EAAA,GAAAgD,SAAA,QACA,wBAAAhD,EAAA,GAAAgD,SAAA,QACA,QACA,WACA,UACA,OACA,gBACA,OAAAhD,EAAA,GAAA7B,UAAA,QACA,OAAA6B,EAAA,GAAA7B,UAAA,QACA,QACA,OACA,sBACA,OAAA6B,EAAA,GAAAmF,eAAA,QACA,OAAAnF,EAAA,GAAAmF,eAAA,QACA,QACA,OACA,iBACA,OAAAnF,EAAA,GAAAoF,UAAA,QACA,OAAApF,EAAA,GAAAoF,UAAA,QACA,QACA,OACA,0BACA,mBAAAnF,EAAA,QACA,QACA,WACA,YACA1B,KAAA,KAGAlD,EAAAJ,QAAAqB,OJwiBMgJ,GAAG,SAAS3K,EAAQU,EAAOJ,IACjC,SAAW+B,GKxvBX,YAaA,SAAAR,GAAAH,GACAH,KAAAG,SAAAA,EACAH,KAAA6D,WAGA7D,KAAAqJ,aAAA/H,EAAA,iBACAtB,KAAAsJ,YAAAhI,EAAA,gBACAtB,KAAAuJ,gBAAAjI,EAAA,oBACAtB,KAAAwJ,MAAAlI,EAAA,SACAtB,KAAAyJ,aAAAnI,EAAA,8BACAtB,KAAA0J,UAAApI,EAAA,cACAtB,KAAA2J,YAAArI,EAAA,gBACAtB,KAAA4J,YAAAtI,EAAA,gCACAtB,KAAA6J,YAAAvI,EAAA,gCACAtB,KAAA8J,YAAAxI,EAAA,gCACAtB,KAAA+J,aAAAzI,EAAA,iBACAtB,KAAAgK,aAAA1I,EAAA,8CACAtB,KAAAiK,sBAAA3I,EAAA,4GACAtB,KAAAkK,kBAAA5I,EAAA,oHACAtB,KAAAmK,UAAA7I,EAAA,cACAtB,KAAAoK,iBAAA9I,EAAA,qBACAtB,KAAAqK,oBAAA/I,EAAA,yBACAtB,KAAAsK,sBAAAhJ,EAAA,iDACAtB,KAAAuK,SAAAjJ,EAAA,6BACAtB,KAAAwK,SAAAlJ,EAAA,4CAEAtB,KAAAyK,0BACAzK,KAAA0K,2BACA1K,KAAA2K,0BAvCA,GAAArJ,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACA8J,EAAAnM,EAAA,+BA+CA6B,GAAAqB,UAAAc,KAAA,SAAAoI,EAAAC,GACA,GAAAhJ,GAAA9B,IAEA,QAAA6K,GACA,IAAA,qBACA/I,EAAAyI,SACAQ,GAAA,mCAAA,qBAAA,SAAA9M,GACA,GAAA+M,GAAA/M,EAAAwK,OACAjJ,EAAAsC,EAAAmJ,OAAAD,GACAzL,EAAA2L,SAAA5J,EAAA0J,GAAAG,MAAA,KAEA,eAAAlN,EAAAwB,MAAA,mBAAAxB,EAAAwB,QAEAxB,EAAAmN,cAAAC,WAAA,GAAApN,EAAAmN,cAAAE,OAAA,EACA/L,GAAA,EAIAA,GAAA,GAIAA,EAAA,EAAAA,EAAA,EAAAA,EAEAuL,EAAAtL,EAAAD,GACAuC,EAAA0E,eAAAhH,EAAA,YAAAD,KAGAwL,GAAA,QAAA,OAAA,SAAA9M,GACAA,EAAAsN,iBAEA,IAAAC,GAAAlK,EAAArD,EAAAwN,gBAAAC,KAAA,sBACAlM,EAAAsC,EAAAmJ,OAAAO,GACAjM,EAAA2L,SAAAM,EAAAL,MAAA,GAEA7J,GAAArD,EAAA0N,eAAAC,SAAA,QACArM,GAAA,EAEAA,EAAAA,EAAA,EAAAA,EAAA,EAAAA,EAGAuL,EAAAtL,EAAAD,GACAuC,EAAA0E,eAAAhH,EAAA,YAAAD,IAEA,MAEA,KAAA,UACAuC,EAAAwH,YAAAyB,GAAA,QAAA,SAAA9M,GACAA,EAAAsN,kBAEAjK,EAAAtB,MAAA6L,QAAA,QACA/J,EAAAsI,iBAAA0B,YAAA,YACArI,WAAA,WACAqH,KACA,MAEA,MAEA,KAAA,eACAhJ,EAAAuH,aAAA0B,GAAA,QAAA,SAAA,WACAzJ,EAAAtB,MAAA+L,UAEA,MAEA,KAAA,gBACAjK,EAAA0I,SAAAqB,SACAG,UAAA,OACA1J,OAAA2J,KAAA,IAAAC,KAAA,GACAC,MAAA,EACAC,UAAA,SACAC,QAAA,UAGAvK,EAAA0H,MAAA8C,WACAC,WAAA,cACAC,WAAA,cACAC,YAAA,mBACAC,KAAA,MAEA,MAEA,KAAA,YACA5K,EAAA+H,YAAAkB,GAAA,SAAA,SAAA9M,GACA,GAAA+M,GAAA/M,EAAAwK,OACAjJ,EAAAsC,EAAAmJ,OAAAD,GAEAjI,EAAAjB,EAAAmJ,OAAA3J,EAAA0J,GAAA2B,QAAA,aACA7K,GAAAkD,kBAAA,OAAAjC,EAEA,IAAAF,GAAAmI,EAAA4B,MAAA,GACA/K,EAAAC,EAAA+K,UAAArN,GACAsD,EAAAxB,EAAA0J,GAAA8B,QACAhC,GAAAjI,EAAAhB,EAAAiB,EAAAC,IAEA,MAEA,KAAA,YACAjB,EAAAgI,YAAAiB,GAAA,eAAA,SAAA9M,GACA,GAAA+M,GAAA/M,EAAAwK,OACA+C,EAAAlK,EAAA0J,GACAjI,EAAAjB,EAAAmJ,OAAAO,EAAAmB,QAAA,aAMA,IAJA,UAAA1O,EAAAwB,MACAqC,EAAAkD,kBAAA,OAAAjC,GAGA,WAAA9E,EAAAwB,KAAA,CACA,GAAAD,GAAAsC,EAAAmJ,OAAAD,GACA/H,EAAAuI,EAAAL,MACAtJ,EAAAC,EAAA+K,UAAArN,EACAsL,GAAA7H,EAAApB,EAAAkB,KAGA,MAEA,KAAA,kBACAjB,EAAAyH,gBAAAwB,GAAA,gBAAA,SAAA,SAAA9M,GACA6D,EAAAiL,mBAAA,OAAA9O,EAAAwK,SAEA,MAEA,KAAA,QACA3G,EAAAyH,gBAAAwB,GAAA,QAAA,mBAAA,SAAA9M,GACAA,EAAAsN,iBAEA,IAAAyB,GAAA1L,EAAA,oBAAA6J,MACA8B,EAAA3L,EAAA,oBAAA6J,KACA7J,GAAA,oBAAA2B,KAAA+J,GACA1L,EAAA,oBAAA2B,KAAAgK,EAEA,IAAA9J,GAAA7B,EAAA,UAAA4L,MAAA,QAAAC,SACArC,GAAA3H,IAEA,MAEA,KAAA,SACA7B,EAAAC,QAAAwJ,GAAA,SAAA,WACAjJ,EAAA4I,2BACA5I,EAAA6I,2BAEA,MAEA,KAAA,gBACA7I,EAAAkI,aAAAe,GAAA,QAAA,IAAA,SAAA9M,GACAA,EAAAmP,iBACAnP,EAAAsN,iBAEA,IAAA8B,GAAA,GAAAzC,GAAA3M,EAAAwK,QACA6E,EAAAD,EAAAE,mBACAF,GAAAG,OAAAF,IAEA,MAEA,KAAA,mBACAxL,EAAA6H,YAAAoB,GAAA,SAAA,yBAAA,SAAA9M,GACA,GAAA+M,GAAA/M,EAAAwK,OACAjJ,EAAAsC,EAAAmJ,OAAAD,GACAnJ,EAAAC,EAAA+K,UAAArN,GACAkD,EAAApB,EAAA0J,GAAAyC,KAAA,WACAxK,EAAAnB,EAAAgI,YAAA4D,GAAA7L,GAAAsJ,KACAL,GAAAjJ,EAAAa,EAAAO,IAEA,MAEA,KAAA,uBACAnB,EAAAwI,sBAAAS,GAAA,SAAA,yBAAA,SAAA9M,GACA,GAAA+M,GAAA/M,EAAAwK,OACAjJ,EAAAsC,EAAAmJ,OAAAD,GACAtI,EAAApB,EAAA0J,GAAAyC,KAAA,UACA3C,GAAAtL,EAAAkD,IAEA,MAEA,KAAA,YACAZ,EAAA8H,YAAAmB,GAAA,eAAA,uBAAA,SAAA9M,GACA,GAAA0P,GAAArM,EAAArD,EAAA2P,eAAAC,KAAA,OACA/L,GAAAkD,kBAAA,OAAA2I,IAEA,MAEA,KAAA,kBACA7L,EAAAqI,UAAAY,GAAA,QAAA,SAAA9M,GACAA,EAAAsN,kBACAzJ,EAAAiL,mBAAA,SAEA,MAEA,KAAA,mBACAjL,EAAA4H,UAAAqB,GAAA,QAAA,SAAA9M,GACAA,EAAAmP,iBACAnP,EAAAsN,kBAEAjK,EAAAtB,MAAA6L,QAAA,QACA/J,EAAAgM,kBAAA,WAEA,MAEA,KAAA,wBACAhM,EAAAuI,oBAAAU,GAAA,QAAA,SAAA9M,GACAA,EAAAmP,iBACAnP,EAAAsN,kBAEAjK,EAAAtB,MAAA6L,QAAA,QACA/J,EAAAsI,iBAAA2D,YAAA,cAIAzM,EAAA,QAAAyJ,GAAA,QAAA,wBAAA,WACAjJ,EAAAsI,iBAAA0B,YAAA,aAEA,MAEA,KAAA,6BACAhK,EAAAsI,iBAAAW,GAAA,QAAA,eAAA,WACAzJ,EAAAtB,MAAA+N,YAAA,WAEA,MAEA,SACA,KAAA,IAAAnP,OAAA,2BASA0B,EAAAqB,UAAAwC,iBAAA,WACA,GAAArC,GAAA9B,IAEA8B,GAAAoI,kBAAA8D,KAAA,WACA1M,EAAAtB,MAAA+L,WAEAjK,EAAAmM,mBAAA,QACAnM,EAAAyB,oBAAA,SASAjD,EAAAqB,UAAAqE,sBAAA,SAAAnE,GACA,GAAAC,GAAA9B,KACA+C,EAAA,cAAAlB,EAAA,EACAP,GAAAyB,EAAA,UAAAuJ,UAAA,SACAxK,EAAAkD,kBAAA,OAAAjC,GACAjB,EAAAwD,QAAA,SAAAvC,IASAzC,EAAAqB,UAAA4D,sBAAA,SAAA1D,GACA,GAAAC,GAAA9B,KACA+C,EAAA,cAAAlB,EAAA,EACAP,GAAAyB,EAAA,aAAAoI,IAAA,IACArJ,EAAAkD,kBAAA,OAAAjC,IAOAzC,EAAAqB,UAAAqC,gBAAA,WACA,GAAAlC,GAAA9B,IACA8B,GAAA3B,SAAA2I,mBAAAhH,EAAA+B,QAAAC,MAAAhC,EAAA+B,QAAAE,eACAjC,EAAA3B,SAAAgJ,iBAAArH,EAAA+B,QAAAC,MAAAhC,EAAA+B,QAAAE,eACAjC,EAAA3B,SAAAkI,mBAAAvG,EAAA+B,QAAAC,QAQAxD,EAAAqB,UAAA+C,oBAAA,WACA,GAAA5C,GAAA9B,KACAkO,IAMA,OAJA5M,GAAA,oBAAA0M,KAAA,WACA,GAAAjL,GAAAjB,EAAAmJ,OAAAjL,KACAkO,GAAAC,KAAApL,KAEAmL,GAUA5N,EAAAqB,UAAA2D,QAAA,SAAAuF,EAAApC,GACA,GAAA3G,GAAA9B,IAEA,QAAA6K,GACA,IAAA,QACA/I,EAAAiE,iBAAA,WACAzE,EAAAmH,GAAAiD,KAAA,OAAA0C,SAAA,UACA9M,EAAAmH,GAAAiD,KAAA,eAAAI,YAAA,SACA,MAEA,KAAA,OACAhK,EAAAiE,iBAAA,UACAzE,EAAAmH,GAAAiD,KAAA,OAAA0C,SAAA,UACA9M,EAAAmH,GAAAiD,KAAA,aAAAI,YAAA,SACA,MAEA,KAAA,SACAhK,EAAAiE,iBAAA,UACAzE,EAAAmH,GAAAiD,KAAA,OAAA0C,SAAA,SACA,MAEA,KAAA,QACAtM,EAAAiE,iBAAA,UACAzE,EAAAmH,GAAAiD,KAAA,OAAA0C,SAAA,UACA9M,EAAAmH,GAAAiD,KAAA,aAAAI,YAAA,SACA,MAEA,SACA,KAAA,IAAAlN,OAAA,2BAQA0B,EAAAqB,UAAAuC,gBAAA,WACA,GAAApC,GAAA9B,IACA8B,GAAAkI,aAAAqE,UAAA,IAUA/N,EAAAqB,UAAA8I,wBAAA,WACA,GAAA3I,GAAA9B,IACA8B,GAAA2H,aAAAgE,KAAA,WAAA,GACA3L,EAAAgI,YAAAqB,IAAA,KAWA7K,EAAAqB,UAAAa,iBAAA,SAAA/C,EAAA0C,EAAAG,GACA,GAAAR,GAAA9B,KACAsO,EAAAxM,EAAA3B,SAAA4H,mBAAAtI,EAAA0C,EAEAL,GAAAuH,aAAAkF,OAAAjN,EAAAgN,IACA7K,WAAA,WACA3B,EAAAuH,aAAAmF,WAAAd,GAAA,GAAA3B,UACAzJ,IAUAhC,EAAAqB,UAAAsC,iBAAA,SAAAL,GAIA,IAAA,GAHA9B,GAAA9B,KACAyO,EAAA7K,EAAA3E,OAEAP,EAAA,EAAA+P,EAAA/P,EAAAA,IAAA,CACA,GAAAgQ,GAAApN,EAAA,OAAAiN,OAAA3K,EAAAlF,GACAoD,GAAAmI,sBAAAyD,GAAAhP,GAAAyN,KAAAuC,GAGA5M,EAAAmM,mBAAA,QACAxK,WAAA,WACA3B,EAAAgM,kBAAA,SACA,KAEAhM,EAAAyB,oBAAA,SASAjD,EAAAqB,UAAAoE,iBAAA,SAAA8E,GACA,GAAA/I,GAAA9B,IACA,QAAA6K,GACA,IAAA,SACA/I,EAAAwH,YAAAmE,KAAA,YAAA,EACA,MAEA,KAAA,UACA3L,EAAAwH,YAAAmE,KAAA,YAAA,EACA,MAEA,SACA,KAAA,IAAA7O,OAAA,2BAYA0B,EAAAqB,UAAAqD,kBAAA,SAAA6F,EAAA9H,GACA,OAAA8H,GACA,IAAA,OACAvJ,EAAAyB,EAAA,iBAAAqL,SAAA,YACA,MAEA,KAAA,OACA9M,EAAAyB,EAAA,iBAAA+I,YAAA,YACA,MAEA,SACA,KAAA,IAAAlN,OAAA,2BAUA0B,EAAAqB,UAAA4B,oBAAA,SAAAsH,GACA,OAAAA,GACA,IAAA,OACA5C,SAAA0G,KAAAxG,UAAA,SACA,MAEA,KAAA,OACAF,SAAA0G,KAAAxG,UAAA,EACA,MAEA,SACA,KAAA,IAAAvJ,OAAA,2BAWA0B,EAAAqB,UAAA6E,eAAA,SAAAhH,EAAAC,EAAAC,GACA,OAAAD,GACA,IAAA,WACA6B,EAAA9B,GAAAiO,KAAA,UAAA/N,EACA,MACA,KAAA,SACA4B,EAAA9B,GAAA2L,IAAAzL,EACA,MACA,SACA4B,EAAA9B,GAAA2L,IAAAzL,KAUAY,EAAAqB,UAAAiN,0BAAA,WACA,GAAA9M,GAAA9B,KACA6O,EAAAvN,EAAA,QAAAwN,aAAA,GACAC,EAAAjN,EAAAiI,aAAAiF,SAAAC,IACAC,EAAAhE,SAAApJ,EAAAiI,aAAAoF,IAAA,eAAA,IACAC,EAAAtN,EAAAkI,aAAA0D,GAAA,GAAAsB,SAAAC,IACAI,EAAAD,EAAAL,CACA,OAAAF,GAAAE,GAAAM,EAAAH,IASA5O,EAAAqB,UAAAsJ,OAAA,SAAAxC,GACA,MAAA,IAAAnH,EAAAmH,GAAAoF,KAAA,OAUAvN,EAAAqB,UAAAkL,UAAA,SAAArN,GACA,GAAA8P,GAAA9P,EAAA+P,MAAA,KACA1N,EAAAyN,EAAAA,EAAArQ,OAAA,EACA,OAAAiM,UAAArJ,EAAA,IAAA,GAGAvB,EAAAqB,UAAAmM,kBAAA,SAAAjD,GACA,GAAA/I,GAAA9B,IACA,QAAA6K,GACA,IAAA,SACAvJ,EAAA,mBAAAwK,YAAA,QACAhK,EAAA6H,YAAAoE,YAAA,WACA,MAEA,KAAA,OACAjM,EAAA6H,YAAAmC,YAAA,WACA,MAEA,SACA,KAAA,IAAAlN,OAAA,2BAUA0B,EAAAqB,UAAAsM,mBAAA,SAAApD,GACA,GAAA/I,GAAA9B,IACA,QAAA6K,GACA,IAAA,OACA/I,EAAAiI,aAAA+B,YAAA,YACA,MAEA,KAAA,OACAhK,EAAAiI,aAAAqE,SAAA,YACA,MAEA,SACA,KAAA,IAAAxP,OAAA,2BAWA0B,EAAAqB,UAAAoL,mBAAA,SAAAlC,EAAApC,GACA,GAAA3G,GAAA9B,IACA,QAAA6K,GACA,IAAA,OACA,GAAA2E,GAAAlO,EAAAQ,EAAA3B,SAAAwI,kBAAA7G,EAAA+B,QAAAC,OACAhC,GAAAyH,gBAAAgF,OAAAiB,GACAA,EAAAtC,MAAA,OACA,MAEA,KAAA,OACA5L,EAAAmH,GAAAsD,QACA,MAEA,SACA,KAAA,IAAAnN,OAAA,2BASA0B,EAAAqB,UAAAgJ,wBAAA,WACA,GAAA7I,GAAA9B,KACAyP,EAAA,EACAC,EAAApO,EAAA,OAAAqO,QACAC,EAAAtO,EAAA,kBAAAuO,aACAC,EAAAxO,EAAA,mBAAAuO,aACAE,EAAAL,GAAAE,EAAAE,EAAAL,EAEA3N,GAAAuH,aAAA8F,KACAa,KAAAJ,EAAA,KACAK,YAAAF,EAAA,QASAzP,EAAAqB,UAAA+I,yBAAA,WACA,GAAA5I,GAAA9B,KACAkQ,EAAApO,EAAA8M,2BAEA9M,GAAAkI,aAAAgE,KAAA,WACA1M,EAAAtB,MAAAmP,IAAA,SAAAe,EAAA,SAIA/Q,EAAAJ,QAAAuB,IL4vBGtB,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,aAExH4O,+BAA+B,IAAIC,GAAG,SAAS3R,EAAQU,EAAOJ,GMz5CjE,YAUA,SAAAsR,GAAAC,EAAAC,EAAAC,GACAxQ,KAAAsQ,WAAAA,EACAtQ,KAAAuQ,cAAAA,EACAvQ,KAAAwQ,UAAAA,EAGArR,EAAAJ,QAAAsR,ON65CMI,GAAG,SAAShS,EAAQU,EAAOJ,IACjC,SAAW+B,GO96CX,YAYA,SAAA8J,GAAAI,GACAhL,KAAA0Q,SAAApP,EAAA0J,GACAhL,KAAA2Q,WAAArP,EAAAtB,KAAA0Q,SAAA5D,SAAAA,SAAAA,UAEA9M,KAAAwL,MAAAlK,EAAAtB,KAAA0Q,SAAA7C,KAAA,SACA7N,KAAA4Q,SAAAtP,EAAAtB,KAAAwL,MAAAsB,UACA9M,KAAA6Q,WAAAvP,EAAAtB,KAAA4Q,SAAA9D,UACA9M,KAAA8Q,QAAAxP,EAAAtB,KAAA6Q,WAAA/D,UAEA9M,KAAA+Q,aAAA/Q,KAAA8Q,QAAA,GAAAE,wBAAAC,OACAjR,KAAAkR,mBAAAhG,SAAAlL,KAAA6Q,WAAA1B,IAAA,eAAA,IAAAjE,SAAAlL,KAAA6Q,WAAA1B,IAAA,kBAAA,IACAnP,KAAAmR,kBAAAC,WAAApR,KAAA4Q,SAAAzB,IAAA,gBACAnP,KAAAqR,qBAAAD,WAAApR,KAAA4Q,SAAAzB,IAAA,mBAtBA,GAAA7N,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACAuP,EAAA5R,EAAA,sBA6BAmM,GAAAjJ,UAAA4L,kBAAA,WACA,GAAAzL,GAAA9B,KACAsR,EAAAxP,EAAA8O,SAAA9B,aAAA,GAAAhN,EAAAoP,mBACAC,EAAArP,EAAAqP,kBACAE,EAAAvP,EAAAuP,qBAEAE,EAAAzP,EAAA4O,SAAA1B,SAAAC,IAAAnN,EAAA6O,WAAA3B,SAAAC,KAAAnN,EAAA0J,MAAAwD,SAAAC,IAAAnN,EAAAgP,QAAA9B,SAAAC,IAGAkC,GAAA,IACAI,GAAAJ,EACAG,GAAAH,EACAA,EAAA,GAIAE,EAAA,IACAC,GAAAD,EACAA,EAAA,EAIA,IAAAG,GAAA1P,EAAAgP,QAAAzC,YAAAkD,CAGA,IAAAC,EAAAF,EAAAxP,EAAAiP,aAAA,CACA,GAAAU,GAAAD,EAAA1P,EAAAiP,aAAA,CACAM,GAAA/M,KAAAoN,IAAAD,GAIA,GAAA,EAAAD,EAAA,CACA,GAAAG,GAAAH,CACAL,GAAA7M,KAAAoN,IAAAC,GACAH,GAAAG,EAGA,MAAA,IAAAtB,GAAAc,EAAAE,EAAAG,IAQA5G,EAAAjJ,UAAA6L,OAAA,SAAAF,GACA,GAAAxL,GAAA9B,IAEA8B,GAAA8O,SAAAgB,SACAC,cAAAvE,EAAAgD,WACAwB,iBAAAxE,EAAAiD,eACA,KAEAzO,EAAAgP,QAAAc,SACAvD,UAAAf,EAAAkD,WACA,MAIArR,EAAAJ,QAAA6L,IPi7CG5L,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,aAExHwQ,sBAAsB,IAAIC,GAAG,SAASvT,EAAQU,EAAOJ,IACxD,SAAW+B,GQ/gDX,YAcA,SAAAU,GAAAqB,EAAAlD,GACAK,KAAA6C,KAAAA,EACA7C,KAAAL,gBAAAA,EAdA,GAAA2B,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACAmR,EAAA,mBAAA1Q,QAAAA,OAAA,MAAA,mBAAAT,GAAAA,EAAA,MAAA,IAwBAU,GAAAG,UAAAiE,cAAA,SAAAF,GACA,GAAA5D,GAAA9B,KACA6C,EAAAf,EAAAe,KACAqP,EAAApQ,EAAAqQ,eACAC,EAAA9Q,EAAA+Q,WACAC,EAAA,GAAAC,WAqBA,QAnBAD,EAAAE,QAAA,SAAAvU,GACA,GAAAuH,GAAAvH,EAAAwK,OAAAjD,KACA,QAAAA,EAAA3G,MACA,IAAA2G,GAAAiN,cACAL,EAAAM,OAAA,kBACA,MACA,KAAAlN,GAAAmN,iBACAP,EAAAM,OAAA,qBACA,MACA,KAAAlN,GAAAoN,UACAR,EAAAM,OAAA,wBACA,MACA,SACAN,EAAAM,OAAA,gDAIAJ,EAAAO,YAAAnN,EAEAwM,GACA,IAAA,OACAI,EAAAQ,OAAA,SAAA7U,GACA,GAAA8U,GAAAjR,EAAAkR,UAAA/U,EAAAwK,OAAAwK,OAEAF,GACA,KAAA9M,KAAA8M,GACAX,EAAAc,QAAAH,GAEAX,EAAAM,OAAA,oCAGAN,EAAAM,OAAA,gDAGAJ,EAAAa,kBAAAtQ,EACA,MAEA,KAAA,MACAyP,EAAAQ,OAAA,SAAA7U,GACA,GAAAmV,GAAAtR,EAAAuR,SAAApV,EAAAwK,OAAAwK,OAEAG,GACA,KAAAnN,KAAAmN,GACAhB,EAAAc,QAAAE,GAEAhB,EAAAM,OAAA,mCAGAN,EAAAM,OAAA,+CAGAJ,EAAAa,kBAAAtQ,EACA,MAEA,KAAA,MACAyP,EAAAQ,OAAA,SAAA7U,GACA,GAAAqV,GAAArV,EAAAwK,OAAAwK,MAEA,IAAAK,EACA,GAAA,KAAArN,KAAAqN,GAAA,CAIA,GAAAC,GAAAD,EAAAE,QAAA,YAAA,KACApB,GAAAc,QAAAK,OAEAnB,GAAAM,OAAA,oCAIAJ,EAAAmB,WAAA5Q,EACA,MAEA,SACAuP,EAAAM,OAAA,4BAGA,MAAAN,GAAAjF,WAcA3L,EAAAG,UAAA+R,qBAAA,SAAAC,EAAAC,EAAAC,GACA,GAAA/R,GAAA9B,KAIA8T,GACAC,MAAA,KACAC,SAAA,KACAC,EAAA,MAEAC,EAAAJ,EAAAH,EAAAQ,WAAA,GACAC,EAAA,EAEA,IAAAT,EAAAU,gBAGA,IAFA,GAAAC,GAAAX,EAAAY,WAEAD,GAIA,cAAAA,EAAAH,UAAA,SAAAG,EAAAH,UAMAC,GADAE,EAAAH,WAAAP,EACAU,EAAAE,YACAF,EAAAH,WAAAN,EACA,KAGA/R,EAAA4R,qBAAAY,EAAAV,EAAAC,GAGAS,EAAAA,EAAAG,aAbAH,EAAAA,EAAAG,WAiBA,OAAAL,GAAAF,GAUA1S,EAAAG,UAAAwQ,aAAA,WACA,GAAArQ,GAAA9B,KACA6C,EAAAf,EAAAe,IAEA,OAAA,SAAAoD,KAAApD,EAAAkE,MACA,OAGA,QAAAd,KAAApD,EAAAkE,MACA,MAGA,QAAAd,KAAApD,EAAAkE,MACA,MADA,QAiBAvF,EAAAG,UAAA+S,gBAAA,SAAA9Q,EAAAgQ,EAAAC,GAKA,IAAA,GAFAW,GAFA1S,EAAA9B,KACAyO,EAAA7K,EAAA3E,OAGAP,EAAA,EAAA+P,EAAA/P,EAAAA,IAAA,CACA,GAAAiV,GAAA/P,EAAAlF,GACAiW,EAAA7S,EAAA4R,qBAAAC,EAAAC,EAAAC,EACAW,IAAAA,EAAAG,GAAAtS,KAAA,IAGA,MAAAmS,IAUAhT,EAAAG,UAAAqR,UAAA,SAAA4B,GACA,GACA3M,GAEA4M,EAGAC,EANAhT,EAAA9B,KAEA+U,EAAA,GAEAnB,EAAA,MACAC,EAAA,MAIA,KACAiB,EAAA,GAAA7C,GAAA2C,EAGA,IAAA/R,GAAAiS,EAAAlI,MAAA,oBAEA,IAAA/J,EAAA,CACAgS,EAAAvT,EAAA0T,SAAAnS,EAAAoS,SACA,IAAAC,GAAA5T,EAAAuT,GAAAnJ,KAAA,kBAAA8C,UACAvG,GAAAnG,EAAA4S,gBAAAQ,EAAAtB,EAAAC,GAIA,IAAA/R,EAAAnC,gBAAA,CAGA,GADAkD,EAAAiS,EAAAlI,MAAA,sBACA,CACAiI,EAAAvT,EAAA0T,SAAAnS,EAAAoS,SACA,IAAAE,GAAA7T,EAAAuT,GAAAnJ,KAAA,4BAAA8C,SAAA,sDACA4G,EAAAtT,EAAA4S,gBAAAS,EAAAvB,EAAAC,EACAuB,KACAL,GAAAA,EAAAK,GAAA/S,KAAA,KAMA,GADAQ,EAAAiS,EAAAlI,MAAA,qBACA,CACAiI,EAAAvT,EAAA0T,SAAAnS,EAAAoS,SACA,IAAAI,GAAA/T,EAAAuT,GAAAnJ,KAAA,0BAAA8C,SAAA,oDACA8G,EAAAxT,EAAA4S,gBAAAW,EAAAzB,EAAAC,EACAyB,KACAP,GAAAA,EAAAO,GAAAjT,KAAA,KAIA0S,GAAAA,EAAA9V,SACAgJ,GAAAA,EAAA,YAAA8M,GAAA1S,KAAA,QAGA,MAAAmD,IAIA,MAAAyC,IAUAzG,EAAAG,UAAA0R,SAAA,SAAAuB,GACA,GACA3M,GAGA6M,EAJAhT,EAAA9B,KAEA4T,EAAA,QACAC,EAAA,iBAIA,KACAiB,EAAA,GAAA7C,GAAA2C,EAGA,IAAA/R,GAAAiS,EAAAlI,MAAA,cAEA,IAAA/J,EAAA,CACA,GAAAgS,GAAAvT,EAAA0T,SAAAnS,EAAAoS,UACAC,EAAA5T,EAAAuT,GAAAnJ,KAAA,uBAAA8C,UAGA,IAFAvG,EAAAnG,EAAA4S,gBAAAQ,EAAAtB,EAAAC,IAEA/R,EAAAnC,gBAAA,CACA,GAAAwV,GAAA7T,EAAA4T,GAAAxJ,KAAA,+BACAqJ,EAAAjT,EAAA4S,gBAAAS,EAAAvB,EAAAC,EAEAkB,IAAAA,EAAA9V,SACAgJ,GAAAA,EAAA,YAAA8M,GAAA1S,KAAA,SAIA,MAAAmD,IAIA,MAAAyC,IAGA9I,EAAAJ,QAAAyC,IRmhDGxC,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,gBAErHgU,IAAI,SAAS9W,EAAQU,EAAOJ,IAClC,SAAW+B,GSx1DX,YAWA,SAAAY,MATA,GAAAJ,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACA0U,EAAA,mBAAAjU,QAAAA,OAAA,QAAA,mBAAAT,GAAAA,EAAA,QAAA,IAmBAY,GAAAC,UAAAyE,cAAA,SAAAnD,GACA,GAAAnB,GAAA9B,KACAoS,EAAA9Q,EAAA+Q,WAEAxM,EAAA,GACAmC,EAAAC,SAAAC,cAAA,MACAF,GAAAI,UAAAnF,CAEA,IAAAwS,GAAA3T,EAAA4R,qBAAA1L,EAgBA,OAdAyN,GAAAxW,QAAA,KAAAgH,KAAAwP,IACA5P,GAAAA,EAAA4P,GAAApT,KAAA,IAEAwD,EAAAA,EAAA2N,QAAA,cAAA,MAEA3N,EAAAA,EAAA2N,QAAA,UAAA,QAGApB,EAAAc,QAAArN,IAGAuM,EAAAM,OAAA,0CAGAN,EAAAjF,WAYAzL,EAAAC,UAAA+R,qBAAA,SAAAC,GACA,GAAA7R,GAAA9B,KAEA0V,EAAAF,EAAA,WACApB,EAAA,GAGAuB,EAAA,SAAAxB,GAIA,IAAA,GAHAyB,IAAA,SAAA,WAAA,SAAA,SACAC,EAAAD,EAAA3W,OAEAP,EAAA,EAAAmX,EAAAnX,EAAAA,IACA,GAAAyV,IAAAyB,EAAAlX,GACA,OAAA,CAGA,QAAA,EAGA,IAAAiX,EAAAhC,EAAAQ,WAAAR,EAAAU,gBAGA,IAFA,GAAAC,GAAAX,EAAAY,WAEAD,GAAA,CAEA,GAAA,IAAAA,EAAAwB,SAAA,CACA,GAAAC,GAAAzB,EAAAE,WACAuB,GAAA9W,SACAmV,GAAA2B,OAEA,CACA,GAAAC,GAAAlU,EAAA4R,qBAAAY,EAGAoB,GAAAzP,KAAAmO,EAAAA,EAAAnV,OAAA,KAAAyW,EAAAzP,KAAA+P,EAAA,MACA5B,GAAA,KAEAA,GAAA4B,EAGA1B,EAAAA,EAAAG,YAIA,MAAAL,IAGAjV,EAAAJ,QAAA2C,IT41DG1C,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,gBAErH0U,IAAI,SAASxX,EAAQU,EAAOJ,IAClC,SAAW+B,GUv8DX,YAEA,IAAAQ,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACA1B,EAAAX,EAAA,eAGA6C,GAAAC,QAAA2U,KAAA,WACAzS,WAAA,WACAnC,EAAA,WAAA8M,SAAA,WACA,IAAAhP,GAAA,cACA,SV48DGJ,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,aAExH4U,eAAe,IAAIC,IAAI,SAAS3X,EAAQU,EAAOJ,GWx9DlD,YAoBA,SAAAsX,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA1W,KAAAsW,UAAAA,EACAtW,KAAAuW,cAAAA,EACAvW,KAAAwW,UAAAA,EACAxW,KAAAyW,cAAAA,EACAzW,KAAA0W,YAAAA,EAGAvX,EAAAJ,QAAAsX,OX49DMM,IAAI,SAASlY,EAAQU,EAAOJ,GYx/DlC,YAYA,SAAA6X,GAAAC,EAAAC,EAAAJ,GACA1W,KAAA6W,OAAAA,EACA7W,KAAA8W,WAAAA,EACA9W,KAAA0W,YAAAA,EACA1W,KAAA+W,WAAAhS,OAUA6R,EAAAjV,UAAAqV,eAAA,SAAA/T,EAAAgU,GACA,GAAAnV,GAAA9B,KACAkX,EAAAjP,SAAAC,cAAA,IAMA,OAJAgP,GAAA1X,IAAAsC,EAAA+U,OAAA,EAAA,IAAA/U,EAAAgV,YAAAzU,KAAA,IACA6U,EAAA/O,UAAArG,EAAAiV,WACAG,EAAAC,MAAA,IAAAF,EAAAJ,OAAA,EAAA,IAAAI,EAAAH,YAAAzU,KAAA,IACA6U,EAAA1C,YAAAvR,EACAiU,GASAN,EAAAjV,UAAAyV,iBAAA,WACA,GAAAtV,GAAA9B,IACA,OAAA8B,GAAAgV,WAAAhV,EAAA4U,aASAE,EAAAjV,UAAA0V,eAAA,SAAA/H,GACA,GAAAxN,GAAA9B,IACA,OAAAsP,GAAAxN,EAAAgV,YAAAQ,aASAV,EAAAjV,UAAA4V,aAAA,SAAAjI,GACA,GAAAxN,GAAA9B,IACA,OAAAsP,GAAAxN,EAAAgV,WAAAhV,EAAA4U,YAAA,GAAAc,WAQAZ,EAAAjV,UAAA8V,cAAA,SAAAtZ,GACA,GAAA2D,GAAA9B,IACA,iBAAA7B,KACA2D,EAAAiV,YAAA,MAAA5Y,EAAA,IAAAkE,KAAA,KAGA,gBAAAlE,KACA2D,EAAAiV,WAAA5Y,IAIAgB,EAAAJ,QAAA6X,OZ4/DMc,IAAI,SAASjZ,EAAQU,EAAOJ,IAClC,SAAW+B,GanlEX,YAeA,SAAAW,GAAAxB,GACAD,KAAAJ,iBAAAK,EAAAmF,kBAAA,oBACApF,KAAAH,cAAAI,EAAAmF,kBAAA,iBACApF,KAAAF,kBAAAG,EAAAmF,kBAAA,qBACApF,KAAAD,cAAAE,EAAAmF,kBAAA,iBACApF,KAAAT,eAAAU,EAAAmF,kBAAA,kBAEApF,KAAA8D,SACA9D,KAAAsP,QAAA,GAAAqI,IACA3X,KAAA+D,cAAA,EAtBA,GAAAzC,GAAA,mBAAAC,QAAAA,OAAA,EAAA,mBAAAT,GAAAA,EAAA,EAAA,KACA0U,EAAA,mBAAAjU,QAAAA,OAAA,QAAA,mBAAAT,GAAAA,EAAA,QAAA,KACAuV,EAAA5X,EAAA,cACAmY,EAAAnY,EAAA,qBACAmZ,EAAAnZ,EAAA,aACAkZ,EAAAlZ,EAAA,aA6BAgD,GAAAE,UAAA+B,QAAA,SAAAzC,GACA,GAAAa,GAAA9B,KACAoS,EAAA9Q,EAAA+Q,WACAwF,KACAC,IAcA,OAXAhW,GAAAiW,WAAA9W,EAAA4W,GAEAC,EAAAhW,EAAAkW,iBAAA,EAAA,EAAAH,GAEAC,EAAA7Y,OAEAmT,EAAAc,QAAApR,EAAAmW,UAAAhX,EAAA6W,IAEA1F,EAAAM,OAAA,0BAGAN,EAAAjF,WAsBA1L,EAAAE,UAAAuW,aAAA,SAAAC,GACA,GAAArW,GAAA9B,KAIAoY,EAAAtW,EAAAuW,kBAAAF,EAAA,GACAG,EAAAF,EAAAnZ,OACAsZ,EAAA,EAGAC,GAAAJ,EAAA,GAAA,GAAAA,EAAA,GAAA,GACAI,GAAA,GAAAf,cAAA,GACAe,EAAA,GAAAf,cAAA,EAIA,KAAA,GAHAgB,IAAAD,GAGA9Z,EAAA,EAAA4Z,EAAA5Z,EAAAA,IAAA,CACA,GAAAga,GAAAD,EAAAA,EAAAxZ,OAAA,GAAA,GACA0Z,EAAAP,EAAA1Z,GAAA,EAGA,IAAAga,EAAA5B,YAAA6B,EAAA7B,WAEA,GAAA4B,EAAAtB,mBAAA,EAAAuB,EAAA7B,WACA0B,GAAAJ,EAAA1Z,GAAA,GAAA0Z,EAAA1Z,GAAA,IACA8Z,EAAA,GAAAf,cAAAc,GACAC,EAAA,GAAAf,cAAAc,GACAE,EAAAtK,KAAAqK,GACAD,QAIA,IAAAG,EAAAtB,mBAAAuB,EAAAvB,mBAAA,CACA,GAAAL,GAAA,eAAA9Q,KAAAyS,EAAA3B,YAAA2B,EAAA3B,WAAA2B,EAAA3B,WAAA,cAGA0B,GAAAA,EAAAxZ,OAAA,GAAA,GAAAwY,cAAAV,GACA0B,EAAAA,EAAAxZ,OAAA,GAAA,GAAAwY,cAAAV,GACA0B,EAAAA,EAAAxZ,OAAA,GAAA,GAAAyX,YAAAiC,EAAA7B,WAAA4B,EAAA5B,WAGA0B,GAAAJ,EAAA1Z,GAAA,GAAA0Z,EAAA1Z,GAAA,IACA8Z,EAAA,GAAAf,cAAAV,GACAyB,EAAA,GAAAf,cAAAV,GACA0B,EAAAtK,KAAAqK,IAOA,MADA1W,GAAAiC,cAAA0U,EAAAxZ,OACAwZ,GAUAhX,EAAAE,UAAAiX,YAAA,WACA,GAAA9W,GAAA9B,KAEA6Y,EAAA,SACAC,EAAA,SACAC,EAAA,EAUA,OARAjX,GAAAjC,gBACAkZ,GAAAF,GAGA/W,EAAAhC,oBACAiZ,GAAAD,GAGAC,EAAA9Z,OAAA,EAAAuW,EAAA,IAAAuD,EAAA,IAAA,KAAAhU,QAUAtD,EAAAE,UAAAqX,gBAAA,SAAApU,GACA,GAAA9C,GAAA9B,KACAiD,EAAA2B,EAEAqU,EAAAnX,EAAA8W,aAUA,OARAK,KACAhW,EAAA2B,EAAA4O,QAAAyF,EAAA,MAGAnX,EAAAlC,mBACAqD,EAAAA,EAAAb,eAGAa,GAWAxB,EAAAE,UAAAuX,WAAA,SAAAC,GACA,GAAArX,GAAA9B,KACAoZ,GACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,MAEAC,EAAAb,CAQA,OANArX,GAAA/B,gBACAia,EAAAb,EAAA3F,QAAA,yBAAA,SAAAlN,GACA,MAAA8S,GAAA9S,MAIA0T,GAiBAvY,EAAAE,UAAAsY,cAAA,SAAA3D,EAAAE,EAAAD,EAAA2D,GAQA,IAAA,GANAC,GACAC,EAFAtY,EAAA9B,KAGAqa,EAAA,EACAC,EAAA,EACAC,EAAA,EAEAC,EAAAjE,EACAiE,EAAA,GAAAA,EAAA1Y,EAAAwN,OAAArQ,OACAub,EAAAN,EAAAM,GAGA,KAAAA,EAAA1Y,EAAAgC,MAAA0S,GAAAM,YAAA,CAIA,GAAAvX,GAAA8a,EAAA,EAAAA,EAAA,EAAAvY,EAAAvC,cAMA,IAJA+a,EAAA/D,EAAAhX,EAAA,EACAgb,EAAAC,EAAAjb,EAAA,EAGA+a,EAAAxY,EAAAgC,MAAAwS,GAAAmE,UACAF,EAAAzY,EAAAgC,MAAA0S,GAAAiE,UACAF,GAAAD,EAAA/a,EAFA,CAKA,IAFA,GAAAmb,GAAAnb,EAEAmb,EAAA,GAAA5Y,EAAAwN,OAAAgL,GAAArX,OAAAnB,EAAAwN,OAAAiL,GAAAtX,MACAqX,IACAC,IACAG,GAGA,MAAAA,EAAA,GAAA,CAQA,GAAAC,GAAApb,CAIA,KAHA+a,EAAA/D,EAAAhX,EACAgb,EAAAC,EAAAjb,EAEA+a,EAAAxY,EAAAgC,MAAAwS,GAAAmE,UACAF,EAAAzY,EAAAgC,MAAA0S,GAAAiE,UACAF,EAAAD,EAAAK,GACA7Y,EAAAwN,OAAAgL,GAAArX,OAAAnB,EAAAwN,OAAAiL,GAAAtX,MACAqX,IACAC,IACAI,GAIAA,IAAA7Y,EAAAvC,gBAAAob,EAAAN,IACAA,EAAAM,EACAP,EAAAI,EACAL,EAAA,GAAA9D,GAAAC,EAAAC,EAAAC,EAAA4D,EAAAC,MAIA,MAAAF,IAkBA1Y,EAAAE,UAAAsW,UAAA,SAAAhX,EAAAkX,GAQA,IAAA,GAPArW,GAAA9B,KACA2E,EAAA1D,EAAAhC,OACA2E,KAEAgX,EAAA9Y,EAAAoW,aAAAC,GAGAzZ,EAAA,EAAAiG,EAAAjG,EAAAA,IAAA,CACA,GAAAkG,GAAA3D,EAAAvC,GAAAuE,KACA4X,EAAA,EACAC,EAAAD,EACAE,EAAAnW,EAAA3F,OACA+b,EAAA,EACAC,EAAA,GAAAvc,EAAAA,EAAA,EAAAA,EAAA,CACAkF,GAAAlF,KAMA,KAHA,GAAA0Z,GAAAtW,EAAAuW,kBAAAuC,EAAAlc,GAGAqc,GAAAF,GAAA,CACA,KAAAzC,EAAAnZ,QAAA+b,EAAA5C,EAAAnZ,QAoBA,CACA,GAAAic,GAAAtW,EAAAuW,MAAAL,EAAAC,GACAK,EAAAnT,SAAAoT,eAAAH,EACAtX,GAAAlF,GAAAyP,KAAAiN,GACAP,EAAAE,CACA,OAxBA,GAAApC,GAAAP,EAAA4C,GAAAtc,GAEA4c,EAAA3C,EAAAtB,eAAAvV,EAAAwN,QAEAiM,EAAA5C,EAAApB,aAAAzV,EAAAwN,QAGAkM,EAAA5W,EAAAuW,MAAAL,EAAAQ,GACA7F,EAAAxN,SAAAoT,eAAAG,EACA5X,GAAAlF,GAAAyP,KAAAsH,EAGA,IAAAgG,GAAA7W,EAAAuW,MAAAG,EAAAC,GACAG,EAAA/C,EAAA3B,eAAAyE,EAAArD,EAAA4C,GAAAC,GACArX,GAAAlF,GAAAyP,KAAAuN,GAEAV,IACAH,EAAAU,EACAT,EAAAD,EAQAA,KAIA,MAAAjX,IAiBAnC,EAAAE,UAAAqW,iBAAA,SAAA1B,EAAAE,EAAA0D,GAMA,IALA,GAAApY,GAAA9B,KACA8X,KACAwC,EAAAxY,EAAAgC,MAAAwS,GAAAQ,WACA6E,EAAA7Z,EAAAgC,MAAAwS,GAAAmE,SAEAH,EAAAxY,EAAAvC,gBAAAoc,GAAA,CACA,GAAAxB,GAAArY,EAAAmY,cAAA3D,EAAAE,EAAA8D,EAAAJ,EAEAC,IAAAA,EAAAzD,YAAA,GACAoB,EAAA3J,MACA,GAAAyI,GAAAuD,EAAA7D,UAAA6D,EAAA5D,cAAA4D,EAAAzD,aACA,GAAAE,GAAAuD,EAAA3D,UAAA2D,EAAA1D,cAAA0D,EAAAzD,eAEA4D,GAAAH,EAAAzD,aAEA4D,IAIA,MAAAxC,IAYArW,EAAAE,UAAAia,uBAAA,SAAA3Y,EAAAiX,EAAA2B,GAMA,IAAA,GALA/Z,GAAA9B,KACAsX,EAAArU,EAAA6T,WACAU,EAAAvU,EAAAwX,SAGA/b,EAAA4Y,EAAA5Y,EAAAoD,EAAAvC,eAAA,EAAAiY,EAAA9Y,IAAA,CAEA,GAAAod,GAAAha,EAAAwN,OAAA6L,MAAAzc,EAAAA,EAAAoD,EAAAvC,gBAAAwc,IAAA,SAAA/B,GACA,MAAAA,GAAA/W,OACAZ,KAAA,GAGAyZ,KAAAD,KAEA3B,EAAA2B,EAAAC,IAAApd,GAGAmd,EAAAC,GAAApd,IAaA+C,EAAAE,UAAAoW,WAAA,SAAA9W,EAAAiZ,GAKA,IAAA,GAJApY,GAAA9B,KACAgc,KACAC,EAAAhb,EAAAhC,OAEAP,EAAA,EAAAud,EAAAvd,EAAAA,IAAA,CACA,GAAAkG,GAAA3D,EAAAvC,GAEAwK,EAAAtE,EAAA3B,KAAA0V,MAAA,WAAA1Z,MAEA6C,GAAAgC,MAAAqK,KAAA,GAAAyJ,GAAAhT,EAAA1C,KAAA0C,EAAA3B,KAAAhE,OAAAiK,EAAAtE,EAAAkC,SAAAhF,EAAAwN,OAAArQ,SAEA6C,EAAAoa,eAAAtX,EAAA3B,MAEAnB,EAAAgC,MAAApF,GAAA+b,SAAA3Y,EAAAwN,OAAArQ,OAEA6C,EAAA8Z,uBAAA9Z,EAAAgC,MAAApF,GAAAwb,EAAA8B,KAcAva,EAAAE,UAAA0W,kBAAA,SAAAF,EAAAtW,GACA,GAAAsa,GAAAhE,EAAAgD,MAAA,EAUA,OARAgB,GAAAC,KAAA,SAAA5d,EAAA6d,GACA,GAAAC,GAAA9d,EAAAqD,GAAAiV,WAAAuF,EAAAxa,GAAAiV,UACA,OAAAwF,GACAA,EAEAD,EAAAxa,GAAA6U,YAAAlY,EAAAqD,GAAA6U,cAGAyF,GAOA1a,EAAAE,UAAAua,eAAA,SAAAtX,GAOA,IANA,GAEA+T,GAFA7W,EAAA9B,KACAuc,EAAA,UAGA1W,EAAA/D,EAAAkX,gBAAApU,GAEA+T,EAAA4D,EAAAC,KAAA3W,IAAA,CACA,GAAAsT,GAAAR,EAAA,GACAqB,EAAAlY,EAAAoX,WAAAC,EAEA,IAAAa,EAAA/a,OAAA,EAAA,CACA,GAAAqY,GAAAqB,EAAA8D,MACAjF,EAAAmB,EAAA8D,MAAAtD,EAAAla,MAEA6C,GAAAwN,OAAAnB,KAAA,GAAAwJ,GAAAqC,EAAA1C,EAAAE,OAKArY,EAAAJ,QAAA0C,IbulEGzC,KAAKgB,KAAuB,mBAAXc,QAAyBA,OAAyB,mBAATgB,MAAuBA,KAAyB,mBAAXP,QAAyBA,aAExHmb,aAAa,GAAGC,oBAAoB,GAAGC,YAAY,GAAGC,aAAa,KAAKC,IAAI,SAASre,EAAQU,EAAOJ,GctlFvG,YAqBA,SAAA6Y,GAAA3V,EAAAgH,EAAAC,EAAApC,EAAAgQ,EAAA2D,GACAza,KAAAiC,UAAAA,EACAjC,KAAA8G,SAAAA,EACA9G,KAAA8W,WAAAA,GAAA,EACA9W,KAAAya,SAAAA,GAAA,EACAza,KAAAiJ,eAAAA,GAAA,EACAjJ,KAAAkJ,UAAAA,GAAA,EAGA/J,EAAAJ,QAAA6Y,Od0lFMmF,IAAI,SAASte,EAAQU,EAAOJ,GexnFlC,YAsBA,SAAA4Y,GAAA1U,EAAAqU,EAAAE;AACAxX,KAAAiD,KAAAA,GAAA,GACAjD,KAAAsX,YAAAA,GAAA,EACAtX,KAAAwX,UAAAA,GAAA,EAGArY,EAAAJ,QAAA4Y,Yf4nFW","file":"app.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar Controller = require('./controller.js');\nvar Storage    = require('./storage.js');\nvar Template   = require('./template.js');\nvar View       = require('./view.js');\n\n/**\n * Creates an instance of the application.\n * @constructor\n * @this  {App}\n * @param {String} namespace - the namespace of the app (i.e. \"simtexter\")\n */\nfunction App(namespace) {\n\t// App's default settings (comparison & input reading options)\n\tvar defaults = {\n\t\t\t'minMatchLength'    : { id: '#min-match-length',   type: 'inputText', value: 4     },\n\t\t\t'ignoreFootnotes'   : { id: '#ignore-footnotes',   type: 'checkbox',  value: false },\n\t\t\t'ignoreLetterCase'  : { id: '#ignore-letter-case', type: 'checkbox',  value: true  },\n\t\t\t'ignoreNumbers'     : { id: '#ignore-numbers',     type: 'checkbox',  value: false },\n\t\t\t'ignorePunctuation' : { id: '#ignore-punctuation', type: 'checkbox',  value: true  },\n\t\t\t'replaceUmlaut'     : { id: '#replace-umlaut',     type: 'checkbox',  value: true  }\n\t\t};\n\t\n\tthis.storage    = new Storage(namespace, defaults);\n\tthis.template   = new Template();\n\tthis.view       = new View(this.template);\n\tthis.controller = new Controller(this.storage, this.view);\n}\n\nmodule.exports = App;","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar Controller = require('./controller.js');\nvar Storage    = require('./storage.js');\nvar Template   = require('./template.js');\nvar View       = require('./view.js');\n\n/**\n * Creates an instance of the application.\n * @constructor\n * @this  {App}\n * @param {String} namespace - the namespace of the app (i.e. \"simtexter\")\n */\nfunction App(namespace) {\n\t// App's default settings (comparison & input reading options)\n\tvar defaults = {\n\t\t\t'minMatchLength'    : { id: '#min-match-length',   type: 'inputText', value: 4     },\n\t\t\t'ignoreFootnotes'   : { id: '#ignore-footnotes',   type: 'checkbox',  value: false },\n\t\t\t'ignoreLetterCase'  : { id: '#ignore-letter-case', type: 'checkbox',  value: true  },\n\t\t\t'ignoreNumbers'     : { id: '#ignore-numbers',     type: 'checkbox',  value: false },\n\t\t\t'ignorePunctuation' : { id: '#ignore-punctuation', type: 'checkbox',  value: true  },\n\t\t\t'replaceUmlaut'     : { id: '#replace-umlaut',     type: 'checkbox',  value: true  }\n\t\t};\n\t\n\tthis.storage    = new Storage(namespace, defaults);\n\tthis.template   = new Template();\n\tthis.view       = new View(this.template);\n\tthis.controller = new Controller(this.storage, this.view);\n}\n\nmodule.exports = App;\n},{\"./controller.js\":2,\"./storage.js\":4,\"./template.js\":5,\"./view.js\":6}],2:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $               = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar FileInputReader = require('../inputReader/fileInputReader.js');\nvar InputText       = require('./inputText.js');\nvar SimTexter       = require('../simtexter/simtexter.js');\nvar TextInputReader = require('../inputReader/textInputReader.js');\n\n/**\n * Creates an instance of a {Controller}, \n * which handles user interaction (data reading, input control, comparison).\n * Interacts with the {View} object to render the final output.\n * @constructor\n * @this  {Controller}\n * @param {Storage} storage - the object that holds the app's settings \n * @param {View}    view    - the app's view\n */\nfunction Controller(storage, view) {\n\tthis.storage              = storage;\n\tthis.view                 = view;\n\tthis.maxCharactersPerPage = 1900;\n\tthis.maxNumberOfPages     = 500;\n\tthis.inputTexts           = [ new InputText(), new InputText() ];\n\t\n\tthis._bindEvents();\n\tthis._updateUI(this.storage.data);\n}\n\n/**\n * Displays a warning message if input is too long (> maxNumberOfPages).\n * @function\n * @private\n * @param {Number} idx - the index of the {InputText} object in inputTexts[]\n */\nController.prototype._alertLongInput = function(idx) {\n\tvar self = this;\n\t\n\t// Compute approximate number of pages for inputText\n\tvar nrOfPages = self.inputTexts[idx].getNumberOfPages(self.maxCharactersPerPage);\n\t// If greater than maximum number of pages, display warning message\n\tif (nrOfPages > self.maxNumberOfPages) {\n\t\tvar inputMode = self.inputTexts[idx].mode;\n\t\tvar message = [\n\t\t\t\tinputMode, ' ', (idx + 1), ' is too long. To prevent visualization issues, please consider truncating this ', inputMode.toLowerCase(), '.' \n\t\t\t].join('');\n\t\tvar delay = self._computeReadingSpeed(message);\n\t\tself.view.showAlertMessage('warning', message, delay);\n\t}\n};\n\n/**\n * Binds events.\n * @function\n * @private\n */\nController.prototype._bindEvents = function() {\n\tvar self = this;\n\t\n\tself.view.bind('changeSpinnerInput', function(id, newValue) {\n\t\tself._updateStorage(id, newValue);\n\t});\n\t\n\tself.view.bind('compare', function() {\n\t\tself._compare();\n\t});\n\t\n\tself.view.bind('dismissAlert');\n\tself.view.bind('hidePrintDialog');\n\tself.view.bind('initBootstrap');\n\t\n\tself.view.bind('inputFile', function(file, idx, loadingElem, tabPaneId) {\n\t\tself._readFile(file, idx, loadingElem, tabPaneId);\n\t});\n\t\n\tself.view.bind('inputText', function(text, idx, tabPaneId) {\n\t\tself._readText(text, idx, tabPaneId);\n\t});\n\t\n\tself.view.bind('print', function(hideModalPromise) {\n\t\tself._print(hideModalPromise);\n\t});\n\t\n\tself.view.bind('resize');\n\tself.view.bind('scrollToMatch');\n\tself.view.bind('selectTab');\n\t\n\tself.view.bind('selectHTMLOption', function(idx, newValue, text) {\n\t\tself.inputTexts[idx].setHTMLOption(newValue);\n\t\tif (text) {\n\t\t\tself._readText(text, idx, self.inputTexts[idx].tabPaneId);\n\t\t}\n\t});\n\t\n\tself.view.bind('selectSettingsOption', function(id, newValue) {\n\t\tself._updateStorage(id, newValue);\n\t});\n\t\n\tself.view.bind('showPrintDialog');\n\tself.view.bind('toggleInputPanel');\n\tself.view.bind('toggleSettingsSidebar');\n\tself.view.bind('toggleSettingsSidebarPanes');\n};\n\n/**\n * Initiates the comparison process.\n * @function\n * @private\n */\nController.prototype._compare = function() {\n\tvar self = this;\n\t\n\tif (self._isInputValid()) {\n\t\tself.view.toggleWaitingCursor('show');\n\t\tvar simtexter = new SimTexter(self.storage);\n\t\t\n\t\tsetTimeout(function() {\n\t\t\tsimtexter.compare(self.inputTexts).then(\n\t\t\t\t// On success, update information nodes and display similarities\n\t\t\t\tfunction(nodes) {\n\t\t\t\t\tself.view.results = {\n\t\t\t\t\t\ttexts         : simtexter.texts,\n\t\t\t\t\t\tuniqueMatches : simtexter.uniqueMatches\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tself.view.createTemplates();\n\t\t\t\t\tself.view.showSimilarities(nodes);\n\t\t\t\t\tself.view.resetScrollbars();\n\t\t\t\t},\n\t\t\t\t// On error, clear output panel and display warning message\n\t\t\t\tfunction(message) {\n\t\t\t\t\tself.view.clearOutputPanel();\n\t\t\t\t\tvar delay = self._computeReadingSpeed(message);\n\t\t\t\t\tself.view.showAlertMessage('info', message, delay);\n\t\t\t\t}\n\t\t\t);\n\t\t}, 200);\n\t}\n};\n\n/**\n * Returns the amount of time in milliseconds\n * that a user needs in order to read a message.\n * @function\n * @private\n * @param {String} message - the message to be read\n */\nController.prototype._computeReadingSpeed = function(message) {\n\tvar minMS = 6000;\n\tvar speed = Math.round(message.length / 40) * 4000;\n\treturn (speed > minMS) ? speed : minMS;\n};\n\n/**\n * Checks if the user has provided a valid input\n * in both source and target input panes.\n * If not, the user is prompted.\n * @function\n * @private\n * @returns {Boolean} - true if input is valid, else false.\n */\nController.prototype._isInputValid = function() {\n\tvar self = this,\n\t\t\tisValid = true,\n\t\t\tactiveTabPaneIds = self.view.getActiveTabPaneIds(),\n\t\t\tiTextsLength = self.inputTexts.length;\n\t\n\tfor (var i = 0; i < iTextsLength; i++) {\n\t\tvar inputText = self.inputTexts[i];\n\t\tvar activeTabPaneId = activeTabPaneIds[i];\n\t\t\n\t\tvar isInputTextValid = (inputText.text !== undefined && inputText.tabPaneId === activeTabPaneId);\n\t\t\n\t\tif (!isInputTextValid) {\n\t\t\tself.view.toggleErrorStatus('show', activeTabPaneId);\n\t\t} else {\n\t\t\tself.view.toggleErrorStatus('hide', activeTabPaneId);\n\t\t}\n\t\t\n\t\tisValid = isValid && isInputTextValid;\n\t}\n\t\n\treturn isValid;\n};\n\n/**\n * Sends the contents of the current window\n * to the system's printer for printing. \n * @function\n * @private\n * @param {Promise} hideModalPromise - a promise that handles the hiding \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t of the 'PRINT OUTPUT' dialog. \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t When resolved, the current window \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is sent to printing.\n */\nController.prototype._print = function(hideModalPromise) {\n\tvar success = function() {\n\t\tsetTimeout(function() {\n\t\t\twindow.print();\n\t\t}, 700);\n\t};\n\t\n\t$.when(hideModalPromise).then(success);\n};\n\n/**\n * Extracts the contents of the selected file\n * and updates the relevant fields of the {InputText} object.\n * @function\n * @private\n * @param {FileList} file        - the file selected by the user\n * @param {Number}   idx         - the index of the {InputText} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in inputTexts[] to be updated.\n *                                 0: input in left-side pane \n *                                 1: input in right-side pane\n * @param {Object}   loadingElem - the node element that shows \n *                                 the progress of reading  \n * @param {String}   tabPaneId   - the id of the active tab pane\n */\nController.prototype._readFile = function(file, idx, loadingElem, tabPaneId) {\n\tvar self = this,\n\t    ignoreFootnotes = self.storage.getItemValueByKey('ignoreFootnotes');\n\t    \n\tvar success = function(text) {\n\t\t\t// Update {InputText} object\n\t\t\tself.inputTexts[idx].setFileInput(file, text, tabPaneId);\n\t\t\tself.view.loading('done', loadingElem);\n\t\t\tself.view.clearTabPaneTextInput(idx);\n\t\t\tself._alertLongInput(idx);\n\t\t};\n\t\t\n\t\tvar error = function(message) {\n\t\t\tself.inputTexts[idx].reset();\n\t\t\tself.view.loading('error', loadingElem);\n\t\t\tself.view.clearTabPaneTextInput(idx);\n\t\t\t\n\t\t\tvar delay = self._computeReadingSpeed(message);\n\t\t\tself.view.showAlertMessage('error', message, delay);\n\t\t};\n\t\n\tif (file) {\n\t\tvar loadingStarted = self.view.loading('start', loadingElem);\n\t\tvar fileInputReader = new FileInputReader(file, ignoreFootnotes);\n\t\tfileInputReader.readFileInput(loadingStarted).then(success, error);\n\t} else {\n\t\tself.view.loading('cancel', loadingElem);\n\t\tself.inputTexts[idx].reset();\n\t}\n};\n\n/**\n * Extracts the contents of the typed/pasted HTML/plain text\n * and updates the relevant fields of the {InputText} object.\n * @function\n * @private\n * @param {String} text      - the HTML/plain text provided by the user\n * @param {Number} idx       - the index of the {InputText} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t in inputTexts[] to be updated.\n *                             0: input in left-side pane, \n *                             1: input in right-side pane\n * @param {String} tabPaneId - the id of the active tab pane\n */\nController.prototype._readText = function(text, idx, tabPaneId) {\n\tvar self = this;\n\t\n\tvar success = function(cleanedText) {\n\t\t// Update {InputText} object\n\t\tself.inputTexts[idx].setTextInput(cleanedText, tabPaneId);\n\t\tself.view.toggleCompareBtn('enable');\n\t\tself.view.clearTabPaneFileInput(idx);\n\t\tself._alertLongInput(idx);\n\t};\n\t\n\tvar error = function(message) {\n\t\tself.inputTexts[idx].reset();\n\t\tself.view.toggleCompareBtn('enable');\n\t\tvar delay = self._computeReadingSpeed(message);\n\t\tself.view.showAlertMessage('error', message, delay);\n\t};\n\t\n\tif (text.length > 0 && /\\S/.test(text)) {\n\t\tif (self.inputTexts[idx].isHTML) {\n\t\t\tself.view.toggleCompareBtn('disable');\n\t\t\tvar textInputReader = new TextInputReader();\n\t\t\ttextInputReader.readTextInput(text).then(success, error);\n\t\t} else {\n\t\t\tsuccess(text);\n\t\t}\n\t} else {\n\t\tself.inputTexts[idx].reset();\n\t}\n};\n\n/**\n * Updates the value of a setting, stored in the {Storage} object.\n * @function\n * @private\n * @param {String}           id       - the id of the setting\n * @param {(Boolean|Number)} newValue - the new value of the setting\n */\nController.prototype._updateStorage = function(id, newValue) {\n\tvar self = this;\n\tself.storage.setItemValueById(id, newValue);\n};\n\n/**\n * Updates the {View} object with the values of the settings,\n * stored in the {Storage} object.\n * @function\n * @private\n * @param {Object} data - the object that holds the storage's settings\n */\nController.prototype._updateUI = function(data) {\n\tvar self = this;\n\t\n\tfor (var key in data) {\n\t\tvar obj = data[key];\n\t\tself.view.updateUIOption(obj.id, obj.type, obj.value);\n\t}\n};\n\nmodule.exports = Controller;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../inputReader/fileInputReader.js\":9,\"../inputReader/textInputReader.js\":10,\"../simtexter/simtexter.js\":14,\"./inputText.js\":3}],3:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {InputText},\n * which holds information on the user input.\n * @constructor\n * @this  {InputText}\n * @param {String} mode      - the mode of input (i.e. \"file\" or \"text\")\n * @param {File}   file      - the file selected by the user\n * @param {String} text      - the input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nfunction InputText(mode, file, text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = mode;\n\tthis.isHTML     = false;\n\tthis.fileName   = (file && file.name);\n\tthis.text       = text;\n}\n\n/**\n * Returns the approximate number of pages of the input string.\n * @function\n * @param   {Number} maxCharactersPerPage - the maximum number of characters \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tper page\n * @returns {Number}                      - the ca. number of pages\n */\nInputText.prototype.getNumberOfPages = function(maxCharactersPerPage) {\n\treturn (this.text.length / maxCharactersPerPage);\n};\n\n/**\n * Resets some fields of the {InputText}.\n * @function\n */\nInputText.prototype.reset = function() {\n\tthis.tabPaneId  = undefined;\n\tthis.mode       = undefined;\n\tthis.fileName   = undefined;\n\tthis.text       = undefined;\n};\n\n/**\n * Sets the fields for the file input.\n * @function\n * @param {File}   file      - the file selected by the user\n * @param {String} text      - the file input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nInputText.prototype.setFileInput = function(file, text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = 'File';\n\tthis.fileName   = file.name;\n\tthis.text       = text;\n};\n\n/**\n * Sets the fields for the text input.\n * @function\n * @param {String} text      - the text input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nInputText.prototype.setTextInput = function(text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = 'Text';\n\tthis.fileName   = (this.isHTML) ? 'HTML text input' : 'Plain text input';\n\tthis.text       = text;\n};\n\nInputText.prototype.setHTMLOption = function(newValue) {\n\tthis.isHTML = newValue;\n};\n\nmodule.exports = InputText;\n},{}],4:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Storage},\n * which stores the values of the app's settings.\n * If local storage is supported by the browser,\n * these settings are also stored under the specified namespace,\n * thus providing the app with a state.\n * The last stored settings will be restored \n * when refreshing the page or restarting the browser. \n * @constructor\n * @this  {Storage}\n * @param {String} namespace - the namespace of the app (i.e. \"simtexter\")\n * @param {Object} data      - the object that holds the app's settings\n */\nfunction Storage(namespace, data) {\n\t this._db  = namespace;\n\t this.data = this._initialize(namespace, data);\n}\n\n/**\n * Returns the value of a setting, retrieved by its key value.\n * @function\n * @param {String} key - the key value of the setting\n */\nStorage.prototype.getItemValueByKey = function(key) {\n\tvar self = this;\n\treturn self._getItemByKey(key).value;\n};\n\n/**\n * Sets the new value of a setting, retrieved by its id value.\n * @function\n * @param {String}           id       - the id of the setting\n * @param {(Boolean|Number)} newValue - the new value of the setting\n */\nStorage.prototype.setItemValueById = function(id, newValue) {\n\tvar self = this,\n\t    item = self._getItemById(id);\n\t\n\titem.value = newValue;\n\tself._save(self.data);\n};\n\n/**\n * Retrieves a setting by its id value.\n * @function\n * @private\n * @param {String} id - the id of the setting\n */\nStorage.prototype._getItemById = function(id) {\n\tvar self = this,\n\t    data = self.data;\n\t\n\tfor (var key in data) {\n\t\tvar obj = data[key];\n\t\tif (obj.id === id) {\n\t\t\treturn obj;\n\t\t}\n\t}\n\t\n\treturn undefined;\n};\n\n/**\n * Retrieves a setting by its key value.\n * @function\n * @private\n * @param {String} key - the key value of the setting\n */\nStorage.prototype._getItemByKey = function(key) {\n\tvar self = this;\n\treturn self.data[key];\n};\n\n/**\n * Stores the app's settings in the web browser's local storage\n * under the specified namespace.\n * If local storage is not supported, stores the settings\n * in {Storage.data}.\n * @function\n * @private\n * @param {String} namespace - the namespace of the app\n * @param {Object} data      - the object that holds the app's settings\n */\nStorage.prototype._initialize = function(namespace, data) {\n\tif (localStorage) {\n\t\tif (!localStorage[namespace]) {\n\t\t\tlocalStorage.setItem(namespace, JSON.stringify(data));\n\t\t} else {\n\t\t\tvar store = localStorage.getItem(namespace);\n\t\t\treturn JSON.parse(store);\n\t\t}\n\t}\n\t\n\treturn data;\n};\n\n/**\n * Stores the settings in the local storage.\n * @function\n * @private\n * @param {Object} data - the data (settings) to be updated\n */\nStorage.prototype._save = function(data) {\n\tif (localStorage && localStorage[this._db]) {\n\t\tlocalStorage.setItem(this._db, JSON.stringify(data));\n\t}\n\tthis.data = data;\n};\n\nmodule.exports = Storage;\n\n},{}],5:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Template},\n * which appends node elements in the DOM or updates their inner content. \n * @constructor\n * @this {Template}\n */\nfunction Template() {\n}\n\n/**\n * Returns the node element of the template\n * for displaying warning messages.\n * @function\n * @param   {String} type    - the type of warning\n * @param   {String} message - the text of the warning message\n * @returns {Object}         - the top node element\n */\nTemplate.prototype.createAlertMessage = function(type, message) {\n\tvar div = document.createElement('div');\n\t\t\n\tdiv.className = 'alert alert-warning';\n\tdiv.innerHTML = [\n\t\t\t'<table class=\"table table-condensed\">',\n\t\t\t\t'<tbody>',\n\t\t\t\t\t'<tr>',\n\t\t\t\t\t\t'<td class=\"h5\"><i class=\"fa fa-exclamation-circle\"></i></td>',\n\t\t\t\t\t\t'<td>',\n\t\t\t\t\t\t\t'<h5>', type, '</h5>',\n\t\t\t\t\t\t\t'<p>', message, '</p>',\n\t\t\t\t\t\t'</td>',\n\t\t\t\t\t'</tr>',\n\t\t\t\t'</tbody>',\n\t\t\t'</table>'\n\t\t].join('');\n\t\t\n\treturn div;\n};\n\n/**\n * Updates the inner HTML content of the output titles.\n * @function\n * @param {Array} texts - the array that holds information about the user input\n */\nTemplate.prototype.createOutputTitles = function(texts) {\n\tvar targets = [ document.getElementById('output-title-1'), document.getElementById('output-title-2') ],\n\t    tLength = targets.length;\n\t\t\n\tfor (var i = 0; i < tLength; i++) {\n\t\tvar fileName = texts[i].fileName || '';\n\t\tvar mode     = texts[i].inputMode;\n\t\tvar target   = targets[i];\n\t\ttarget.innerHTML = [\n\t\t\t\t'<p><b>', mode.toUpperCase(), ': </b>', fileName, '</p> ',\n\t\t\t].join('');\n\t}\n};\n\n/**\n * Returns the node element of the template\n * for displaying the \"PRINT OUTPUT\" dialog.\n * @function\n * @param   {Array} texts - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\tabout the user input\n * @returns {Object}      - the top node element\n */\nTemplate.prototype.createPrintDialog = function(texts) {\n\tvar section = document.createElement('section');\n\t\n\tsection.id = 'modal-print';\n\tsection.className = 'modal fade';\n\tsection.setAttribute('tabindex', '-1');\n\tsection.setAttribute('role', 'dialog');\n\tsection.innerHTML = [\n\t\t\t'<div class=\"modal-dialog\">',\n\t      '<div class=\"modal-content\">',\n          '<div class=\"modal-header\">',\n            '<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">',\n              '<span aria-hidden=\"true\">&times;</span>',\n            '</button>',\n            '<h4 class=\"modal-title\">Print output</h4>',\n          '</div>',\n          '<div class=\"modal-body\">',\n            '<div class=\"row\">',\n              '<div class=\"col-xs-6\">',\n                '<div class=\"form-group form-group-sm\">',\n                  '<label for=\"input-comment-1\">1: Comment for ', texts[0].inputMode, '</label>',\n                  '<textarea id=\"input-comment-1\" class=\"form-control\" rows=\"5\" autocomplete=\"off\" placeholder=\"Type a comment\"></textarea>',\n                '</div>',\n              '</div>',\n              '<div class=\"col-xs-6\">',\n                '<div class=\"form-group form-group-sm\">',\n                  '<label for=\"input-comment-2\">2: Comment for ', texts[1].inputMode, '</label>',\n                  '<textarea id=\"input-comment-2\" class=\"form-control\" rows=\"5\" autocomplete=\"off\" placeholder=\"Type a comment\"></textarea>',\n                '</div>',\n              '</div>',\n            '</div>',\n          '</div>',\n          '<div class=\"modal-footer\">',\n            '<button type=\"button\" class=\"btn btn-default btn-sm\" data-dismiss=\"modal\">Cancel</button>',\n            '<button id=\"modal-print-btn\" type=\"button\" class=\"btn btn-primary btn-sm\">Print</button>',\n          '</div>',\n\t      '</div>',\n      '</div>'\n\t\t].join('');\n\t\t\n\treturn section;\n};\n\n/**\n * Updates the inner HTML content of the hidden, on screen, node element\n * that holds the information (statistics & comments) to be printed.\n * @function\n * @param {Array}  texts         - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t about the user input\n * @param {Number} uniqueMatches - the number of the unique matches found\n */\nTemplate.prototype.createPrintSummary = function(texts, uniqueMatches) {\n\tvar target = document.getElementById('print-summary');\n\t\t\n\ttarget.innerHTML = [\n\t\t\t'<h4>COMPARISON SUMMARY</h4>',\n\t\t\t'<h6>DATE/TIME: ', (new Date()).toUTCString(), '</h6>',\n\t\t  '<table class=\"table table-condensed table-bordered\">',\n\t      '<thead>',\n\t        '<tr>',\n\t          '<th class=\"col-xs-2\"></th>',\n\t          '<th class=\"col-xs-5\">', texts[0].fileName, '</th>',\n\t          '<th class=\"col-xs-5\">', texts[1].fileName, '</th>',\n\t        '</tr>',\n\t      '</thead>',\n\t      '<tbody>',\n\t      \t'<tr>',\n\t          '<th>Comment</th>',\n\t          '<td id=\"print-comment-1\"></td>',\n\t          '<td id=\"print-comment-2\"></td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Type</th>',\n\t          '<td>', texts[0].inputMode, '</td>',\n\t          '<td>', texts[1].inputMode, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Characters</th>',\n\t          '<td>', texts[0].nrOfCharacters, '</td>',\n\t          '<td>', texts[1].nrOfCharacters, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Words</th>',\n\t          '<td>', texts[0].nrOfWords, '</td>',\n\t          '<td>', texts[1].nrOfWords, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Unique matches</th>',\n\t          '<td colspan=\"2\">', uniqueMatches, '</td>',\n\t        '</tr>',\n\t      '</tbody>',\n\t\t  '</table>'\n\t\t].join('');\n};\n\n/**\n * Updates the inner HTML content\n * of the node element that holds the statistical data. \n * @function\n * @param {Array}  texts         - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t about the user input\n * @param {Number} uniqueMatches - the number of the unique matches found\n */\nTemplate.prototype.createStatistics = function(texts, uniqueMatches) {\n\tvar target = document.getElementById('statistics');\n\t\t\n\ttarget.innerHTML = [\n\t\t  '<table class=\"table table-condensed table-bordered\">',\n\t      '<thead>',\n          '<tr>',\n            '<th class=\"col-xs-2\"></th>',\n            '<th class=\"col-xs-5\">', texts[0].fileName, '</th>',\n            '<th class=\"col-xs-5\">', texts[1].fileName, '</th>',\n          '</tr>',\n\t      '</thead>',\n\t      '<tbody>',\n          '<tr>',\n            '<th>Type</th>',\n            '<td>', texts[0].inputMode, '</td>',\n            '<td>', texts[1].inputMode, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Characters</th>',\n            '<td>', texts[0].nrOfCharacters, '</td>',\n            '<td>', texts[1].nrOfCharacters, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Words</th>',\n            '<td>', texts[0].nrOfWords, '</td>',\n            '<td>', texts[1].nrOfWords, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Unique matches</th>',\n            '<td colspan=\"2\">', uniqueMatches, '</td>',\n          '</tr>',\n\t      '</tbody>',\n\t\t  '</table>'\n\t\t].join('');\n};\n\nmodule.exports = Template;\n},{}],6:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $           = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar TargetMatch = require('../autoScroll/targetMatch.js');\n\n/**\n * Creates an instance of a {View},\n * which implements all the UI logic of the application.\n * @constructor\n * @this  {View}\n * @param {Template} template - the object that appends/updates elements \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the DOM\n */\nfunction View(template) {\n\tthis.template = template;\n\tthis.results  = {};\n\t\n\t// Selectors\n\tthis.$alertsPanel          = $('#alerts-panel');\n\tthis.$compareBtn           = $('#compare-btn');\n\tthis.$contentWrapper       = $('#content-wrapper');\n\tthis.$file                 = $(':file');\n\tthis.$htmlOptions          = $('#html-text-1, #html-text-2');\n\tthis.$inputLnk             = $('#input-lnk');\n\tthis.$inputPanel           = $('#input-panel');\n\tthis.$inputPanes           = $('#input-pane-1, #input-pane-2');\n\tthis.$inputFiles           = $('#input-file-1, #input-file-2');\n\tthis.$inputTexts           = $('#input-text-1, #input-text-2');\n\tthis.$outputPanel          = $('#output-panel');\n\tthis.$outputTexts          = $('#comparison-output-1, #comparison-output-2');\n\tthis.$outputTextContainers = $('#comparison-output-1 > .comparison-output-container, #comparison-output-2 > .comparison-output-container');\n\tthis.$outputParagraphs     = $('#comparison-output-1 > .comparison-output-container > p, #comparison-output-2 > .comparison-output-container > p');\n\tthis.$printBtn             = $('#print-btn');\n\tthis.$settingsSidebar      = $('#settings-sidebar');\n\tthis.$settingsSidebarLnk   = $('#settings-sidebar-lnk');\n\tthis.$settingsSidebarPanes = $('#comparison-options-pane, #input-options-pane');\n\tthis.$spinner              = $('#min-match-length-spinner');\n\tthis.$tooltip              = $('[data-toggle=\"tooltip\"], [rel=\"tooltip\"]');\n\t\n\tthis._resetTextInputTabPanes();\n\tthis._updateOutputPanelHeight();\n\tthis._updateAlertsPanelWidth();\n}\n\n/**\n * Binds events depending on the name specified.\n * @function\n * @param {String} event     - the name of the event\n * @param {Function} handler - the callback function\n */\nView.prototype.bind = function(event, handler) {\n\tvar self = this;\n\t\n\tswitch (event) {\n\t\tcase 'changeSpinnerInput':\n\t\t\tself.$spinner\n\t\t\t\t.on('change mousewheel DOMMouseScroll', 'input[type=\"text\"]', function(e) {\n\t\t\t\t\t\tvar elem = e.target;\n\t\t\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t  \t\tvar minMatchLength = parseInt($(elem).val(), 10);\n\t\t\t\t  \t\t\n\t\t\t\t  \t\tif (e.type === 'mousewheel' || e.type === 'DOMMouseScroll') {\n\t\t\t\t\t  \t\t// scrolling up\n\t\t\t\t  \t\t\tif (e.originalEvent.wheelDelta > 0 || e.originalEvent.detail < 0) {\n\t\t\t\t\t\t        minMatchLength += 1;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    // scrolling down\n\t\t\t\t\t\t    else {\n\t\t\t\t\t\t        minMatchLength -= 1;\n\t\t\t\t\t\t    }\n\t\t\t\t  \t\t}\n\t\t\t\t  \t\t\n\t\t\t\t  \t\tminMatchLength = (minMatchLength < 1) ? 1 : minMatchLength; \n\t\t\t\t\t\t\n\t\t\t\t\t\thandler(id, minMatchLength);\n\t\t\t\t    \tself.updateUIOption(id, 'inputText', minMatchLength);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.on('click', '.btn', function(e) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\n\t\t\t\t\tvar $elem = $(e.delegateTarget).find('input[type=\"text\"]');\n\t\t\t\t\tvar id = self._getId($elem);\n\t\t  \t\tvar minMatchLength = parseInt($elem.val(), 10);\n\t\t\t\t\t\n\t\t\t\t\tif ($(e.currentTarget).hasClass('plus')) {\n\t\t\t\t\t\tminMatchLength += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminMatchLength = (minMatchLength > 1) ? (minMatchLength - 1) : minMatchLength;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\thandler(id, minMatchLength);\n\t\t\t\t    self.updateUIOption(id, 'inputText', minMatchLength);\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'compare':\n\t\t\tself.$compareBtn.on('click', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself.$settingsSidebar.removeClass('expanded');\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\thandler();\n\t\t\t\t}, 200);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'dismissAlert':\n\t\t\tself.$alertsPanel.on('click', '.alert', function() {\n\t\t\t\t$(this).remove();\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'initBootstrap':\n\t\t\tself.$tooltip.tooltip({\n\t\t\t\tcontainer : 'body',\n\t\t\t\tdelay     : { \"show\": 800, \"hide\": 0 },\n\t\t\t\thtml      : true,\n\t\t\t\tplacement : 'bottom',\n\t\t\t\ttrigger   : 'hover'\n\t\t\t});\n\t\t\t\n\t\t\tself.$file.filestyle({\n\t\t\t\tbuttonName  : \"btn-primary\",\n\t\t\t\tbuttonText  : \"Browse file\",\n\t\t\t\tplaceholder : \"No file selected\",\n\t\t\t\tsize        : \"sm\"\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'inputFile':\n\t\t\tself.$inputFiles.on('change', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t\n\t\t\t\tvar tabPaneId = self._getId($(elem).parents('.tab-pane'));\n\t\t\t\tself.toggleErrorStatus('hide', tabPaneId);\n\t\t\t\t\n\t\t\t\tvar file = elem.files[0];\n\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\tvar loadingElem = $(elem).parent();\n\t\t\t\thandler(file, idx, loadingElem, tabPaneId);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'inputText':\n\t\t\tself.$inputTexts.on('change input', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar $elem = $(elem);\n\t\t\t\tvar tabPaneId = self._getId($elem.parents('.tab-pane'));\n\t\t\t\t\n\t\t\t\tif (e.type === 'input') {\n\t\t\t\t\tself.toggleErrorStatus('hide', tabPaneId);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e.type === 'change') {\n\t\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t\tvar text = $elem.val();\n\t\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\t\thandler(text, idx, tabPaneId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'hidePrintDialog':\n\t\t\tself.$contentWrapper.on('hide.bs.modal', '.modal', function(e) {\n\t\t\t\tself._togglePrintDialog('hide', e.target);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'print':\n\t\t\tself.$contentWrapper.on('click', '#modal-print-btn', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\tvar inputComment1  = $('#input-comment-1').val();\n\t\t\t\tvar inputComment2  = $('#input-comment-2').val();\n\t\t\t\t$('#print-comment-1').text(inputComment1);\n\t\t\t\t$('#print-comment-2').text(inputComment2);\n\t\t\t\t\n\t\t\t\tvar hideModalPromise = $('.modal').modal('hide').promise();\n\t\t\t\thandler(hideModalPromise);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'resize':\n\t\t\t$(window).on('resize', function() {\n\t\t\t\tself._updateOutputPanelHeight();\n\t\t\t\tself._updateAlertsPanelWidth();\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'scrollToMatch':\n\t\t\tself.$outputTexts.on('click', 'a', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\tvar targetMatch = new TargetMatch(e.target);\n\t\t\t\tvar scrollPosition = targetMatch.getScrollPosition();\n\t\t\t\ttargetMatch.scroll(scrollPosition);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectHTMLOption':\n\t\t\tself.$inputPanel.on('change', 'input[type=\"checkbox\"]', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\tvar newValue = $(elem).prop('checked');\n\t\t\t\tvar text = self.$inputTexts.eq(idx).val();\n\t\t\t\thandler(idx, newValue, text);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectSettingsOption':\n\t\t\tself.$settingsSidebarPanes.on('change', 'input[type=\"checkbox\"]', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\tvar newValue = $(elem).prop('checked');\n\t\t\t\thandler(id, newValue);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectTab':\n\t\t\tself.$inputPanes.on('shown.bs.tab', 'a[data-toggle=\"tab\"]', function(e) {\n\t\t\t\tvar lastTabPaneId = $(e.relatedTarget).attr('href');\n\t\t\t\tself.toggleErrorStatus('hide', lastTabPaneId);\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'showPrintDialog':\n\t\t\tself.$printBtn.on('click', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tself._togglePrintDialog('show');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleInputPanel':\n\t\t\tself.$inputLnk.on('click', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t// Hide tooltip (if any)\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself._toggleInputPanel('toggle');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleSettingsSidebar':\n\t\t\tself.$settingsSidebarLnk.on('click', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t// Hide tooltip (if any)\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself.$settingsSidebar.toggleClass('expanded');\n\t\t\t});\n\t\t\n\t\t\t// Hide settings sidebar when clicking inside the 'nav' and '#content-wrapper' elements\n\t\t\t$('body').on('click', 'nav, #content-wrapper', function() {\n\t\t\t\tself.$settingsSidebar.removeClass('expanded');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleSettingsSidebarPanes':\n\t\t\tself.$settingsSidebar.on('click', '.panel-title', function() {\n\t\t\t\t$(this).toggleClass('active');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Removes all <p> nodes from each output pane\n * and hides the output panel.\n * @function\n */\nView.prototype.clearOutputPanel = function() {\n\tvar self = this;\n\t\n\tself.$outputParagraphs.each(function() {\n\t\t$(this).remove();\n\t});\n\tself._toggleOutputPanel('hide');\n\tself.toggleWaitingCursor('hide');\n};\n\n/**\n * Clears all input from the \"FILE\" tab pane.\n * @function\n * @param {Number} idx - the number of the tab pane\n *                       0: for left-side pane, 1: for right-side pane\n */\nView.prototype.clearTabPaneFileInput = function(idx) {\n\tvar self = this;\n\tvar tabPaneId = '#tab-file-' + (idx + 1);\n\t$(tabPaneId + ' input').filestyle('clear');\n\tself.toggleErrorStatus('hide', tabPaneId);\n\tself.loading('cancel', tabPaneId);\n};\n\n/**\n * Clears all input from the \"TEXT\" tab pane.\n * @function\n * @param {Number} idx - the number of the tab pane\n *                       0: for left-side pane, 1: for right-side pane\n */\nView.prototype.clearTabPaneTextInput = function(idx) {\n\tvar self = this;\n\tvar tabPaneId = '#tab-text-' + (idx + 1);\n\t$(tabPaneId + ' textarea').val('');\n\tself.toggleErrorStatus('hide', tabPaneId);\n};\n\n/**\n * Creates the node templates.\n * @function\n */\nView.prototype.createTemplates = function() {\n\tvar self = this;\n\tself.template.createPrintSummary(self.results.texts, self.results.uniqueMatches);\n\tself.template.createStatistics(self.results.texts, self.results.uniqueMatches);\n\tself.template.createOutputTitles(self.results.texts);\n};\n\n/**\n * Returns the ids of active tab panes as an array of strings.\n * @function\n * @returns {Array<String>} - the ids of the active tab panes\n */\nView.prototype.getActiveTabPaneIds = function() {\n\tvar self = this,\n\t\ttabPaneIds = [];\n\t\t\n\t$('.tab-pane.active').each(function() {\n\t\tvar tabPaneId = self._getId(this);\n\t\ttabPaneIds.push(tabPaneId);\n\t});\n\treturn tabPaneIds;\n};\n\n/**\n * Shows/hides an node element depending on the event specified.\n * Used to show the progress of a process (e.g. input reading).\n * @function\n * @param {String} event  - the name of the event\n * @param {Object} target - the id of the node element\n */\nView.prototype.loading = function(event, target) {\n\tvar self = this;\n\t\n\tswitch (event) {\n\t\tcase 'start':\n\t\t\tself.toggleCompareBtn('disable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-spinner').removeClass('hidden');\n\t\t\tbreak;\n\t\t\n\t\tcase 'done':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-check').removeClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'cancel':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'error':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-times').removeClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Resets the scroll bars.\n * @function\n */\nView.prototype.resetScrollbars = function() {\n\tvar self = this;\n\tself.$outputTexts.scrollTop(0);\n};\n\n/**\n * Clears text from textarea and unchecks checkboxes.\n * Important for Internet Explorer, \n * since it does not recognize the \"autocomplete='off'\" attribute.\n * @function\n * @private\n */\nView.prototype._resetTextInputTabPanes = function() {\n\tvar self = this;\n\tself.$htmlOptions.prop('checked', false);\n\tself.$inputTexts.val('');\n};\n\n/**\n * Displays a warning message.\n * @function\n * @param {String} type    - the type of the message\n * @param {String} message - the text of the message\n * @param {Number} delay   - the time in milliseconds, during which the message \n *                           should remain visible\n */\nView.prototype.showAlertMessage = function(type, message, delay) {\n\tvar self = this,\n\t\t\talertMessage = self.template.createAlertMessage(type, message);\n\t\n\tself.$alertsPanel.append($(alertMessage));\n\tsetTimeout(function() {\n\t\tself.$alertsPanel.children().eq(0).remove();\n\t}, delay);\n};\n\n/**\n * Appends the array of nodes returned by the comparison \n * to the <p> node element of each output pane \n * and shows the output panel.\n * @function\n * @param {Array} nodes - the array of nodes returned by the comparison\n */\nView.prototype.showSimilarities = function(nodes) {\n\tvar self = this,\n\t\t\tnLength = nodes.length;\n\t\t\n\tfor (var i = 0; i < nLength; i++) {\n\t\tvar $p = $('<p>').append(nodes[i]);\n\t\tself.$outputTextContainers.eq(i).html($p);\n\t}\n\t\n\tself._toggleOutputPanel('show');\n\tsetTimeout(function() {\n\t\tself._toggleInputPanel('hide');\n\t}, 100);\n\t\n\tself.toggleWaitingCursor('hide');\n};\n\n/**\n * Enables/disables the compare button\n * depending on the event specified.\n * @function\n * @param {String} event - the name of the event\n */\nView.prototype.toggleCompareBtn = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'enable':\n\t\t\tself.$compareBtn.prop('disabled', false);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'disable':\n\t\t\tself.$compareBtn.prop('disabled', true);\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Toggles the class \"has-error\", \n * which applies a red border around input node elements,\n * to prompt the user in case of erroneous input.\n * @function\n * @param {String} event     - the name of the event\n * @param {String} tabPaneId - the id of the tab pane\n */\nView.prototype.toggleErrorStatus = function(event, tabPaneId) {\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\t$(tabPaneId + ' .apply-error').addClass('has-error');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\t$(tabPaneId + ' .apply-error').removeClass('has-error');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Toggles the style of the cursor (from \"default\" to \"waiting\", and vice versa)\n * depending on the event specified.\n * @function\n * @param {String} event - the name of the event\n */\nView.prototype.toggleWaitingCursor = function(event) {\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tdocument.body.className = 'waiting';\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tdocument.body.className = '';\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Updates the value of a setting in the UI.\n * @function\n * @param {String}           id    - the id of the control element \n * @param {String}           type  - the type of the control element\n * @param {(Boolean|Number)} value - the value of the setting\n */\nView.prototype.updateUIOption = function(id, type, value) {\n\tswitch (type) {\n\t\tcase 'checkbox':\n\t\t\t$(id).prop('checked', value);\n\t\t\tbreak;\n\t\tcase 'select':\n\t\t\t$(id).val(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$(id).val(value);\n\t}\n};\n\n/**\n * Calculates the height of the output pane\n * so that it fits entirely in the window.\n * @function\n * @private\n */\nView.prototype._computeOutputPanelHeight = function() {\n\tvar self = this;\n\tvar bodyHeight = $('body').outerHeight(true);\n\tvar outputPos  = self.$outputPanel.offset().top;\n\tvar outputTopPadding = parseInt(self.$outputPanel.css('padding-top'), 10);\n\tvar elemPos    = self.$outputTexts.eq(0).offset().top;\n\tvar posOffset  = (elemPos - outputPos);\n\treturn bodyHeight - outputPos - (posOffset + outputTopPadding);\n};\n\n/**\n * Returns the id of a node element as a string (e.g. \"#id\").\n * @function\n * @param   {Object} target - the id of the node element\n * @returns {String}        - the string of the node element's id \n */\nView.prototype._getId = function(target) {\n\treturn '#' + $(target).attr('id');\n};\n\n/**\n * Returns the number contained in the id of a node element.\n * @function\n * @private\n * @param   {String} id - the id of the node element\n * @returns {Number}    - the number of the id\n */\nView.prototype._getIndex = function(id) {\n\tvar tokens = id.split('-'); \n\tvar idx = tokens[tokens.length - 1];\n\treturn parseInt(idx, 10) - 1;\n};\n\nView.prototype._toggleInputPanel = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'toggle':\n\t\t\t$('.btn-group.open').removeClass('open');\n\t\t\tself.$inputPanel.toggleClass('expanded');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tself.$inputPanel.removeClass('expanded');\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Shows/hides the output panel depending on the event specified.\n * @function\n * @private\n * @param {String} event - the name of the event\n */\nView.prototype._toggleOutputPanel = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tself.$outputPanel.removeClass('invisible');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tself.$outputPanel.addClass('invisible');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Shows/hides the \"PRINT OUTPUT\" dialog depending on the event specified.\n * @function\n * @private\n * @param {String} event  - the name of the event\n * @param {Object} target - the node element to be removed\n */\nView.prototype._togglePrintDialog = function(event, target) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tvar $printDialog = $(self.template.createPrintDialog(self.results.texts));\n\t\t\tself.$contentWrapper.append($printDialog);\n\t\t\t$printDialog.modal('show');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\t$(target).remove();\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Updates the width of the alerts' panel.\n * @function\n * @private\n */\nView.prototype._updateAlertsPanelWidth = function() {\n\tvar self        = this,\n\t\t\tmarginLR      = 3 * 2,\n\t\t\tnavWidth      = $('nav').width(),\n\t\t\tnavLeftWidth  = $('nav .pull-left').outerWidth(),\n\t\t\tnavRightWidth = $('nav .pull-right').outerWidth(),\n\t\t\tmaxWidth      = navWidth - (navLeftWidth + navRightWidth + marginLR);\n\t\t\n\tself.$alertsPanel.css({\n\t\t'left'      : navLeftWidth + 'px',\n\t\t'max-width' : maxWidth + 'px'\n\t});\n};\n\n/**\n * Updates the height of each output pane.\n * @function\n * @private\n */\nView.prototype._updateOutputPanelHeight = function() {\n\tvar self = this,\n\t\t\th = self._computeOutputPanelHeight();\n\n\tself.$outputTexts.each(function() {\n\t\t$(this).css('height', h + 'px');\n\t});\n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../autoScroll/targetMatch.js\":8}],7:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {ScrollPosition}.\n * @constructor\n * @this  {ScrollPosition}\n * @param {Number} topPadding    - the top padding\n * @param {Number} bottomPadding - the bottom padding\n * @param {Number} yPosition     - the vertical position of the scroll bar\n */\nfunction ScrollPosition(topPadding, bottomPadding, yPosition) {\n\tthis.topPadding    = topPadding;\n\tthis.bottomPadding = bottomPadding;\n\tthis.yPosition     = yPosition;\n}\n\nmodule.exports = ScrollPosition;\n\n},{}],8:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $              = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar ScrollPosition = require('./scrollPosition.js');\n\n/**\n * Creates an instance of a {TargetMatch},\n * which hold information on the target match node element.\n * @constructor\n * @this  {TargetMatch}\n * @param {elem} elem - the source match node\n */\nfunction TargetMatch(elem) {\n\tthis.$srcElem             = $(elem);\n\tthis.$srcParent           = $(this.$srcElem.parent().parent().parent());\n\t\n\tthis.$elem                = $(this.$srcElem.attr('href'));\n\tthis.$wrapper             = $(this.$elem.parent());\n\tthis.$container           = $(this.$wrapper.parent());\n\tthis.$parent              = $(this.$container.parent());\n\t\n\tthis.parentHeight         = this.$parent[0].getBoundingClientRect().height;\n\tthis.containerTBPadding   = parseInt(this.$container.css('padding-top'), 10) + parseInt(this.$container.css('padding-bottom'), 10);\n\tthis.wrapperTopPadding    = parseFloat(this.$wrapper.css('padding-top'));\n\tthis.wrapperBottomPadding = parseFloat(this.$wrapper.css('padding-bottom'));\n}\n\n/**\n * Returns the new scroll position of the target match node.\n * @function\n * @returns {ScrollPosition} - the new scroll position\n */\nTargetMatch.prototype.getScrollPosition = function() {\n\tvar self                 = this,\n\t    wrapperBottom        = self.$wrapper.outerHeight(true) + self.containerTBPadding,\n\t    wrapperTopPadding    = self.wrapperTopPadding,\n\t    wrapperBottomPadding = self.wrapperBottomPadding,\n\t    // Calculate difference on the y axis (relative to parent element)\n\t    yPosDiff             = (self.$srcElem.offset().top - self.$srcParent.offset().top) - (self.$elem.offset().top - self.$parent.offset().top);\n\t\n\t// Remove top padding\n\tif (wrapperTopPadding > 0) {\n\t\tyPosDiff += wrapperTopPadding;\n\t\twrapperBottom -= wrapperTopPadding;\n\t\twrapperTopPadding = 0;\n\t}\n\t\n\t// Remove bottom padding\n\tif (wrapperBottomPadding > 0) {\n\t\twrapperBottom -= wrapperBottomPadding;\n\t\twrapperBottomPadding = 0;\n\t}\n\t\n\t// Compute new scroll position\n\tvar yScrollPos = self.$parent.scrollTop() - yPosDiff; \n\t\n\t// Add bottom padding, if needed\n\tif (yScrollPos > (wrapperBottom - self.parentHeight)) {\n\t\tvar bottomOffset = (yScrollPos + self.parentHeight) - (wrapperBottom);\n\t\twrapperBottomPadding = Math.abs(bottomOffset);\n\t}\n\t\n\t// Add top padding, if needed\n\tif (yScrollPos < 0) {\n\t\tvar topOffset = yScrollPos;\n\t\twrapperTopPadding = Math.abs(topOffset);\n\t\tyScrollPos -= topOffset;\n\t}\n\t\n\treturn new ScrollPosition(wrapperTopPadding, wrapperBottomPadding, yScrollPos);\n};\n\n/**\n * Animates scrolling to the new position.\n * @function\n * @param {ScrollPosition} scrollPosition - the new scroll position\n */\nTargetMatch.prototype.scroll = function(scrollPosition) {\n\tvar self = this;\n\t\n\tself.$wrapper.animate({\n\t\t'padding-top'    : scrollPosition.topPadding,\n\t\t'padding-bottom' : scrollPosition.bottomPadding,\n\t}, 700);\n\t\n\tself.$parent.animate({\n\t\t'scrollTop'      : scrollPosition.yPosition,\n\t}, 700);\n\t\n};\n\nmodule.exports = TargetMatch;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./scrollPosition.js\":7}],9:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $     = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar JSZip = (typeof window !== \"undefined\" ? window['JSZip'] : typeof global !== \"undefined\" ? global['JSZip'] : null);\n\n/**\n * Creates an instance of a {FileInputReader},\n * which parses and extracts the text contents of the DOCX, ODT and TXT files.\n * @constructor\n * @this  {FileInputReader}\n * @param {File}    file            - the file selected by the user\n * @param {Boolean} ignoreFootnotes - the option for including/excluding \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe document's footnotes from parsing\n */\nfunction FileInputReader(file, ignoreFootnotes) {\n\tthis.file            = file;\n\tthis.ignoreFootnotes = ignoreFootnotes;\n}\n\n/**\n * Returns a promise that handles the file reading.\n * When resolved, the contents of the file are returned as a string. \n * @function\n * @param   {Function} loadingStarted - the callback function \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  for the onloadstart event\n * @returns {Promise} \n */\nFileInputReader.prototype.readFileInput = function(loadingStarted) {\n\tvar self     = this,\n\t\t\tfile     = self.file,\n\t\t\tfileType = self._getFileType(),\n\t\t\tdeferred = $.Deferred(),\n\t\t\tfr       = new FileReader();\n\t\n\tfr.onerror = function(e) {\n\t\tvar error = e.target.error;\n\t\tswitch (error.code) {\n\t\t\tcase error.NOT_FOUND_ERR:\n\t\t\t\tdeferred.reject('File not found!');\n\t\t\t\tbreak;\n\t\t\tcase error.NOT_READABLE_ERR:\n\t\t\t\tdeferred.reject('File not readable.');\n\t\t\t\tbreak;\n\t\t\tcase error.ABORT_ERR:\n\t\t\t\tdeferred.reject('File reading aborted.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdeferred.reject('An error occurred while reading this file.');\n\t\t}\n\t};\n\t\n\tfr.onloadstart = loadingStarted;\n\t\n\tswitch (fileType) {\n\t\tcase 'docx':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar docxText = self._readDOCX(e.target.result);\n\t\t\t\t\n\t\t\t\tif (docxText) {\n\t\t\t\t\tif (/\\S/.test(docxText)) {\n\t\t\t\t\t\tdeferred.resolve(docxText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected DOCX file is empty.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject('The selected file is not a valid DOCX file.');\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsArrayBuffer(file);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'odt':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar odtText = self._readODT(e.target.result);\n\t\t\t\t\n\t\t\t\tif (odtText) {\n\t\t\t\t\tif (/\\S/.test(odtText)) {\n\t\t\t\t\t\tdeferred.resolve(odtText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected ODT file is empty.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject('The selected file is not a valid ODT file.');\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsArrayBuffer(file);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'txt':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar txtText = e.target.result;\n\t\t\t\t\n\t\t\t\tif (txtText) {\n\t\t\t\t\tif (/\\S/.test(txtText)) {\n\t\t\t\t\t\t// Mac uses carriage return, which is not processed correctly\n\t\t\t\t\t\t// Replace each carriage return, not followed by a line feed\n\t\t\t\t\t\t// with a line feed\n\t\t\t\t\t\tvar crCleanedText = txtText.replace(/\\r(?!\\n)/g, '\\n');\n\t\t\t\t\t\tdeferred.resolve(crCleanedText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected TXT file is empty.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsText(file);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tdeferred.reject('File type not supported.');\n\t}\n\t\n\treturn deferred.promise();\n};\n\n/**\n * Traverses recursively all children starting from the top XML node,\n * irrespective of how deep the nesting is.\n * Returns their text contents as a string.\n * @function\n * @private\n * @param   {Object} node       - the top XML node element\n * @param   {String} tSelector  - the selector for text elements\n * @param   {String} brSelector - the selector for soft line breaks\n * @returns {String}            - the text content of the node\n */\nFileInputReader.prototype._extractTextFromNode = function(node, tSelector, brSelector) {\n\tvar self = this,\n\t\t\t// Paragraph selectors for both DOCX and ODT, \n\t\t\t// supported both by Chrome and other browsers\n\t\t\t// Chrome uses different selectors \n\t\t\tdelimeters = {\n\t\t\t\t'w:p'    : '\\n',\n\t\t\t\t'text:p' : '\\n',\n\t\t\t\t'p'      : '\\n'\n\t\t\t},\n\t\t\tdelimeter = delimeters[node.nodeName] || '',\n\t\t\tstr  = '';\n\t\t\n\tif (node.hasChildNodes()) {\n\t\tvar child = node.firstChild;\n\t\t\n\t\twhile (child) {\n\t\t\t// These selectors apply only to the footnotes of ODT files\n\t\t\t// Footnotes should appear all together at the end of the extracted text \n\t\t\t// and not inside the text at the point where the reference is.\n\t\t\tif (child.nodeName === 'text:note' || child.nodeName === 'note') {\n\t\t\t\tchild = child.nextSibling;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (child.nodeName === tSelector) {\n\t\t\t\tstr += child.textContent;\n\t\t\t} else if (child.nodeName === brSelector) {\n\t\t\t\tstr += '\\n';\n\t\t\t} \n\t\t\telse {\n\t\t\t\tstr += self._extractTextFromNode(child, tSelector, brSelector);\n\t\t\t}\n\t\t\t\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\t\n\treturn str + delimeter;\n};\n\n/**\n * Returns the type of file depending on the file's extension.\n * @function\n * @private\n * @param   {Object} file - the file selected by the user\n * @returns {String}      - the type of file\n */\nFileInputReader.prototype._getFileType = function() {\n\tvar self = this,\n\t\t\tfile = self.file;\n\t\n\tif (/docx$/i.test(file.name)) {\n\t\treturn 'docx';\n\t}\n\t\n\tif (/odt$/i.test(file.name)) {\n\t\treturn 'odt';\n\t}\n\t\n\tif (/txt$/i.test(file.name)) {\n\t\treturn 'txt';\n\t}\n\t\n\treturn undefined;\n};\n\n/**\n * Returns the contents of all XML nodes as a string.\n * \n * @function\n * @private\n * @param   {Object[]} nodes    - the array of XML nodes\n * @param   {String} tSelector  - the selector for text elements\n * @param   {String} brSelector - the selector for soft line breaks\n * @returns {String}            - the text content of all XML nodes\n */\nFileInputReader.prototype._getTextContent = function(nodes, tSelector, brSelector) {\n\tvar self    = this,\n\t\t\tnLength = nodes.length,\n\t\t\ttextContent;\n\t\n\tfor (var i = 0; i < nLength; i++) {\n\t\tvar node = nodes[i];\n\t\tvar nodeContent = self._extractTextFromNode(node, tSelector, brSelector);\n\t\ttextContent = [textContent, nodeContent].join('');\n\t}\n\t\n\treturn textContent;\n};\n\n/**\n * Returns the contents of the DOCX file as a string.\n * @function\n * @private\n * @param   {Object} fileContents - the contents of the file object\n * @returns {String}              - the text of the DOCX file\n */\nFileInputReader.prototype._readDOCX = function(fileContents) {\n\tvar self = this,\n\t\t\tdocument,\n\t\t\tfootnotes  = '',\n\t\t\txmlDoc,\n\t\t\ttSelector  = 'w:t',\n\t\t\tbrSelector = 'w:br',\n\t\t\tzip;\n\n\t// Unzip the file\n\ttry {\n\t\tzip = new JSZip(fileContents);\n\t\n\t\t// Read the main text of the DOCX file\n\t\tvar file = zip.files['word/document.xml'];\n\t\t\t\n\t\tif (file) {\n\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\tvar pNodes = $(xmlDoc).find('w\\\\:body, body').children();\n\t\t\tdocument = self._getTextContent(pNodes, tSelector, brSelector);\n\t\t}\n\t\t\n\t\t// Read footnotes/endnotes\n\t\tif (!self.ignoreFootnotes) {\n\t\t\t// Read footnotes\n\t\t\tfile = zip.files['word/footnotes.xml'];\n\t\t\tif (file) {\n\t\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\t\tvar fNodes = $(xmlDoc).find('w\\\\:footnotes, footnotes').children('w\\\\:footnote:not([w\\\\:type]), footnote:not([type])');\n\t\t\t\tvar fNodesText = self._getTextContent(fNodes, tSelector, brSelector);\n\t\t\t\tif (fNodesText) {\n\t\t\t\t\tfootnotes = [footnotes, fNodesText].join('');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Read endnotes\n\t\t\tfile = zip.files['word/endnotes.xml'];\n\t\t\tif (file) {\n\t\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\t\tvar eNodes = $(xmlDoc).find('w\\\\:endnotes, endnotes').children('w\\\\:endnote:not([w\\\\:type]), endnote:not([type])');\n\t\t\t\tvar eNodesText = self._getTextContent(eNodes, tSelector, brSelector);\n\t\t\t\tif (eNodesText) {\n\t\t\t\t\tfootnotes = [footnotes, eNodesText].join('');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (footnotes && footnotes.length) {\n\t\t\t\tdocument = [document, 'FOOTNOTES', footnotes].join('\\n'); \n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t\n\t}\n\t\n\treturn document;\n};\n\n/**\n * Returns the contents of the ODT file as a string.\n * @function\n * @private\n * @param   {Object} fileContents - the contents of the file object\n * @returns {String}              - the text of the ODT file\n */\nFileInputReader.prototype._readODT = function(fileContents) {\n\tvar self = this,\n\t\t\tdocument, \n\t\t\ttSelector  = '#text', \n\t\t\tbrSelector = 'text:line-break',\n\t\t\tzip;\n\t\n\t// Unzip the file\n\ttry {\n\t\tzip = new JSZip(fileContents);\n\n\t\t// Read the main text, as well as the footnotes/endnotes of the ODT file\n\t\tvar file = zip.files['content.xml'];\n\t\t\n\t\tif (file) {\n\t\t\tvar xmlDoc = $.parseXML(file.asText());\n\t\t\tvar pNodes = $(xmlDoc).find('office\\\\:body, body').children();\n\t\t\tdocument = self._getTextContent(pNodes, tSelector, brSelector);\n\t\t\t\n\t\t\tif (!self.ignoreFootnotes) {\n\t\t\t\tvar fNodes = $(pNodes).find('text\\\\:note-body, note-body');\n\t\t\t\tvar footnotes = self._getTextContent(fNodes, tSelector, brSelector);\n\t\t\t\t\n\t\t\t\tif (footnotes && footnotes.length) {\n\t\t\t\t\tdocument = [document, 'FOOTNOTES', footnotes].join('\\n'); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t\n\t}\n\t\n\treturn document;\n};\n\nmodule.exports = FileInputReader;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],10:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $       = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar XRegExp = (typeof window !== \"undefined\" ? window['XRegExp'] : typeof global !== \"undefined\" ? global['XRegExp'] : null);\n\n/**\n * Creates an instance of a {TextInputReader},\n * which parses and extracts the text contents of the HTML text input.\n * @constructor\n * @this {TextInputReader}\n */\nfunction TextInputReader() {\n}\n\n/**\n * Returns a promise that handles the HTML input reading.\n * When resolved, the contents of the HTML text\n * are returned as a string. \n * @function\n * @param   {String} text - the HTML text input\n * @returns {Promise}\n */\nTextInputReader.prototype.readTextInput = function(text) {\n\tvar self     = this,\n\t\t\tdeferred = $.Deferred();\n\t\t\n\tvar cleanedText = '';\n\tvar div = document.createElement('div');\n\tdiv.innerHTML = text;\n\n\tvar textNode = self._extractTextFromNode(div);\n\t// If is not empty or not contains only white spaces\n\tif (textNode.length && /\\S/.test(textNode)) {\n\t\tcleanedText = [cleanedText, textNode].join('');\n\t\t// Remove multiple white spaces\n\t\tcleanedText = cleanedText.replace(/\\n[ \\t\\v]*/g, '\\n');\n\t\t// Remove multiple newlines\n\t\tcleanedText = cleanedText.replace(/\\n{3,}/g, '\\n\\n');\n\t\t\n\t\t// Resolve\n\t\tdeferred.resolve(cleanedText);\n\t} else {\n\t\t// Reject\n\t\tdeferred.reject('HTML input has no valid text contents.');\n\t}\n\t\t\n\treturn deferred.promise();\n};\n\n/**\n * Traverses recursively all child nodes, \n * irrespective of how deep the nesting is.\n * Returns the HTML text contents as a string.\n * @function\n * @private\n * @param   {Object} node - the parent HTML node element\n * @returns {String}      - the text content of the HTML string\n */\nTextInputReader.prototype._extractTextFromNode = function(node) {\n\tvar self = this,\n\t\t\t// Match any letter\n\t\t\tletterRegex = XRegExp('^\\\\pL+$'),\n\t\t\tstr = '';\n\t\n\t// Returns whether a node should be skipped\n\tvar isValidNode = function(nodeName) {\n\t\tvar skipNodes       = ['IFRAME', 'NOSCRIPT', 'SCRIPT', 'STYLE'],\n\t\t\t\tskipNodesLength = skipNodes.length;\n\t\t\t\n\t\tfor (var i = 0; i < skipNodesLength; i++) {\n\t\t\tif (nodeName === skipNodes[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true; \n\t};\n\t\n\tif (isValidNode(node.nodeName) && node.hasChildNodes()) {\n\t\tvar child = node.firstChild;\n\t\t\n\t\twhile (child) {\n\t\t\t// If text node\n\t\t\tif (child.nodeType === 3) {\n\t\t\t\tvar content = child.textContent;\n\t\t\t\tif (content.length) {\n\t\t\t\t\tstr += content;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar extractedContent = self._extractTextFromNode(child);\n\t\t\t\t// Add a space between text nodes that are not separated \n\t\t\t\t// by a space or newline (e.g. as in lists)\n\t\t\t\tif (letterRegex.test(str[str.length - 1]) && letterRegex.test(extractedContent[0])) {\n\t\t\t\t\tstr += ' ';\n\t\t\t\t}\n\t\t\t\tstr += extractedContent;\n\t\t\t}\n\t\t\t\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\t\n\treturn str;\n};\n\nmodule.exports = TextInputReader;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],11:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $   = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar App = require('./app/app.js');\n\n// Main execution entry point\n$(window).load(function() {\n\tsetTimeout(function() {\n\t\t$(\".loader\").addClass('shrinked');\n\t\tvar app = new App('simtexter');\n\t}, 700);\n});\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./app/app.js\":1}],12:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Records a match found in the source and the target text.\n * @constructor\n * @this  {Match}\n * @param {Number} srcTxtIdx     - the index of the source text \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.texts[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is found\n * @param {Number} srcTkBeginPos - the index of the source text's token \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.tokens[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t starts \n * @param {Number} trgTxtIdx     - the index of the target text\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.texts[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is found\n * @param {Number} trgTkBeginPos - the index of the target text's token \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.tokens[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t starts\n * @param {Number} matchLength   - the length of the match \n */\nfunction Match(srcTxtIdx, srcTkBeginPos, trgTxtIdx, trgTkBeginPos, matchLength) {\n\tthis.srcTxtIdx     = srcTxtIdx;\n\tthis.srcTkBeginPos = srcTkBeginPos;\n\tthis.trgTxtIdx     = trgTxtIdx;\n\tthis.trgTkBeginPos = trgTkBeginPos;\n\tthis.matchLength   = matchLength;\n}\n\nmodule.exports = Match;\n\n},{}],13:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Records a match found in a text.\n * @constructor\n * @this  {MatchSegment}\n * @param {Number} txtIdx      - the index of the text in {SimTexter.texts[]},\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t where the match has been found\n * @param {Number} tkBeginPos  - the index of the token in {SimTexter.tokens[]},\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t where the match starts \n * @param {Number} matchLength - the length of the match\n */\nfunction MatchSegment(txtIdx, tkBeginPos, matchLength) {\n\tthis.txtIdx      = txtIdx;\n\tthis.tkBeginPos  = tkBeginPos;\n\tthis.matchLength = matchLength;\n\tthis.styleClass  = undefined;\n}\n\n/**\n * Returns the match's link node.\n * @function\n * @param {String}       text            - the text content of the node \n * @param {MatchSegment} trgMatchSegment - the target match segment\n * @returns                              - the match's link node\n */\nMatchSegment.prototype.createLinkNode = function(text, trgMatchSegment) {\n\tvar self = this,\n    \tmatchLink = document.createElement('a');\n    \t\n    matchLink.id          = [self.txtIdx + 1, '-', self.tkBeginPos].join('');\n    matchLink.className   = self.styleClass;\n    matchLink.href        = ['#', trgMatchSegment.txtIdx+1, '-', trgMatchSegment.tkBeginPos].join('');\n    matchLink.textContent = text;\n    return matchLink;\n};\n\n/**\n * Returns the index of the token in {SimTexter.tokens[]},\n * where the match ends.\n * @function\n * @returns {Number} - the last token position of the match (non-inclusive)\n */\nMatchSegment.prototype.getTkEndPosition = function() {\n\tvar self = this;\n\treturn self.tkBeginPos + self.matchLength;\n};\n\n/**\n * Returns the index of the character in the input string,\n * where the match starts.\n * @function\n * @returns {Number} - the first character of the match in the input string \n */\nMatchSegment.prototype.getTxtBeginPos = function(tokens) {\n\tvar self = this;\n    return tokens[self.tkBeginPos].txtBeginPos;\n};\n\n/**\n * Returns the index of the character in the input string,\n * where the match ends.\n * @function\n * @returns {Number} - the last character of the match in the input string \n */\nMatchSegment.prototype.getTxtEndPos = function(tokens) {\n\tvar self = this;\n    return tokens[self.tkBeginPos + self.matchLength - 1].txtEndPos;\n};\n\n/**\n * Sets the style class of the match segment.\n * @function\n * @param {(Number|String)} n - the style class to be applied\n */\nMatchSegment.prototype.setStyleClass = function(n) {\n\tvar self = this;\n\tif (typeof n === 'number') {\n\t\tself.styleClass = ['hl-', n % 10].join('');\n\t}\n\t\n\tif (typeof n === 'string') {\n\t\tself.styleClass = n;\n\t}\n};\n\nmodule.exports = MatchSegment;\n\n},{}],14:[function(require,module,exports){\n(function (global){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $            = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar XRegExp      = (typeof window !== \"undefined\" ? window['XRegExp'] : typeof global !== \"undefined\" ? global['XRegExp'] : null);\nvar Match        = require('./match.js');\nvar MatchSegment = require('./matchSegment.js');\nvar Text         = require('./text.js');\nvar Token        = require('./token.js');\n\n/**\n * Creates an instance of {SimTexter}.\n * @constructor\n * @param {this}        SimTexter\n * @param {Object}      storage   - the object that holds the app's settings\n */\nfunction SimTexter(storage) {\n\tthis.ignoreLetterCase  = storage.getItemValueByKey('ignoreLetterCase');\n\tthis.ignoreNumbers     = storage.getItemValueByKey('ignoreNumbers');\n\tthis.ignorePunctuation = storage.getItemValueByKey('ignorePunctuation');\n\tthis.replaceUmlaut     = storage.getItemValueByKey('replaceUmlaut');\n\tthis.minMatchLength    = storage.getItemValueByKey('minMatchLength');\n\t\n\tthis.texts             = [];\n\tthis.tokens            = [new Token()];\n\tthis.uniqueMatches     = 0;\n}\n\n/**\n * Returns a promise that handles the comparison process.\n * When resolved, an array of nodes is returned,\n * which holds the text and the highlighted matches.\n * @function\n * @param {Array<InputText>} inputTexts - the array of {InputText} objects \n *                                        which hold information about the user \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\tinput\n */\nSimTexter.prototype.compare = function(inputTexts) {\n\tvar self     = this,\n\t\t\tdeferred = $.Deferred(),\n\t\t\tforwardReferences = [],\n\t\t\tsimilarities = [];\n\t\n\t\t// Read input (i.e. cleaning, tokenization)\n\t\tself._readInput(inputTexts, forwardReferences);\n\t\t// Get matches\n\t\tsimilarities = self._getSimilarities(0, 1, forwardReferences);\n\n\t\tif (similarities.length) {\n\t\t\t// Return input string as HTML nodes\n\t\t\tdeferred.resolve(self._getNodes(inputTexts, similarities));\n\t\t} else {\n\t\t\tdeferred.reject('No similarities found.');\n\t\t}\n\t\n\treturn deferred.promise();\n};\n\n/**\n * Applies a style class to each match segment\n * and removes duplicates from the array of matches.\n * Duplicates or overlapping segments can be traced,\n * if one observes the target {MatchSegment} objects \n * stored in the array matches.\n * Sorting of matches by target {MatchSegment}, \n * with its tkBeginPos in ascending order \n * and its matchLength in descending order,\n * makes removal of duplicates easy to handle.\n * The first {MatchSegment} with a given tkBeginPos\n * has the longest length. All others with the same tkBeginPos\n * have the same or a smaller length, and thus can be discarded.\n * @function\n * @private\n * @param   {Array} matches - the array that holds the match segments, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\tstored in pairs\n * @returns {Array}         - the array of unique matches\n */\nSimTexter.prototype._applyStyles = function(matches) {\n\tvar self = this;\n\t\n\t// Sort matches by target {MatchSegment},\n\t// where tkBeginPos in ascending order and matchLength in descending order\n\tvar sortedMatches = self._sortSimilarities(matches, 1);\n\tvar sortedMatchesLength = sortedMatches.length;\n\tvar styleClassCnt = 1;\n\t\n\t// Add first match in array of unique matches to have a starting point\n\tvar uniqueMatch = [sortedMatches[0][0], sortedMatches[0][1]];\n\tuniqueMatch[0].setStyleClass(0);\n\tuniqueMatch[1].setStyleClass(0);\n\tvar aUniqueMatches = [uniqueMatch];\n\n\t// For each match in sortedMatches[]\n\tfor (var i = 1; i < sortedMatchesLength; i++) {\n\t\tvar lastUniqueMatch = aUniqueMatches[aUniqueMatches.length - 1][1];\n\t\tvar match = sortedMatches[i][1];\n\t\t\n\t\t// If not duplicate\n\t\tif (lastUniqueMatch.tkBeginPos != match.tkBeginPos) {\n\t\t\t// if not overlapping\n\t\t\tif (lastUniqueMatch.getTkEndPosition() - 1 < match.tkBeginPos) {\n\t\t\t\tuniqueMatch = [sortedMatches[i][0], sortedMatches[i][1]];\n\t\t\t\tuniqueMatch[0].setStyleClass(styleClassCnt);\n\t\t\t\tuniqueMatch[1].setStyleClass(styleClassCnt);\n\t\t\t\taUniqueMatches.push(uniqueMatch);\n\t\t\t\tstyleClassCnt++;\n\t\t\t} else {\n\t\t\t\t// end-to-start overlapping\n\t\t\t\t// end of lastUniqueMatch overlaps with start of match\n\t\t\t\tif (lastUniqueMatch.getTkEndPosition() < match.getTkEndPosition()) {\n\t\t\t\t\tvar styleClass = ( /overlapping$/.test(lastUniqueMatch.styleClass) ) ? lastUniqueMatch.styleClass : lastUniqueMatch.styleClass + ' overlapping';\n\t\t\t\t\t// Overwrite the style of the last unique match segment \n\t\t\t\t\t// and change its length accordingly\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][0].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][1].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][1].matchLength = match.tkBeginPos - lastUniqueMatch.tkBeginPos;\n\t\t\t\t\t\n\t\t\t\t\t// Add the new match segment\n\t\t\t\t\tuniqueMatch = [sortedMatches[i][0], sortedMatches[i][1]];\n\t\t\t\t\tuniqueMatch[0].setStyleClass(styleClass);\n\t\t\t\t\tuniqueMatch[1].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches.push(uniqueMatch);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\n\tself.uniqueMatches = aUniqueMatches.length;\n\treturn aUniqueMatches;\n};\n\n/**\n * Returns a regular expression depending on the comparison options set.\n * Uses the XRegExp category patterns.\n * @function\n * @private\n * @returns {XRegExp} - the regular expression\n */\nSimTexter.prototype._buildRegex = function() {\n\tvar self = this,\n\t\t\t// XRegExp patterns\n\t\t\tNUMBERS     = '\\\\p{N}',\n\t\t\tPUNCTUATION = '\\\\p{P}',\t\t\n\t\t\tregex       = '';\n\t\n\tif (self.ignoreNumbers) {\n\t\tregex += NUMBERS;\n\t}\n\t\n\tif (self.ignorePunctuation) {\n\t\tregex += PUNCTUATION;\n\t}\n\t\t\n\treturn (regex.length > 0) ? XRegExp('[' + regex + ']', 'g') : undefined;\n};\n\n/**\n * Cleans the input string according to the comparison options set.\n * @function\n * @private\n * @param   {String} inputText - the input string\n * @returns {String}           - the cleaned input string\n */\nSimTexter.prototype._cleanInputText = function(inputText) {\n\tvar self = this,\n\t\t\ttext = inputText;\n\t\t\t\n\tvar langRegex = self._buildRegex();\n\t\n\tif (langRegex) {\n\t\ttext = inputText.replace(langRegex, ' ');\n\t}\n\t\n\tif (self.ignoreLetterCase) {\n\t\ttext = text.toLowerCase();\n\t}\n\t\n\treturn text;\n};\n\n/**\n * Returns a \"cleaned\" word, according to the comparison options set.\n * @function\n * @private\n * @param   {String} word - a sequence of characters, separated by one \n *                          or more white space characters (space, tab, newline)\n * @returns {String}      - the cleaned word\n */\nSimTexter.prototype._cleanWord = function(word) {\n\tvar self = this,\n\t\t\tumlautRules = {\n\t\t\t\t'ä': 'ae',\n\t\t  \t'ö': 'oe',\n\t\t  \t'ü': 'ue',\n\t\t  \t'ß': 'ss',\n\t\t  \t'æ': 'ae',\n\t\t  \t'œ': 'oe',\n\t\t  \t'Ä': 'AE',\n\t\t  \t'Ö': 'OE',\n\t\t  \t'Ü': 'UE',\n\t\t  \t'Æ': 'AE',\n\t\t  \t'Œ': 'OE'\n\t\t\t},\n\t\t\ttoken = word;\n\t\n\tif (self.replaceUmlaut) {\n\t\ttoken = word.replace(/ä|ö|ü|ß|æ|œ|Ä|Ö|Ü|Æ|Œ/g, function(key){\n\t\t\treturn umlautRules[key];\n\t\t});\n\t}\n\t\n\treturn token;\n};\n\n/**\n * Finds the longest common substring in the source and the target text\n * and returns the best match.\n * @function\n * @private\n * @param   {Number} srcTxtIdx     - the index of the source text in texts[] \n *                                   to be compared\n * @param   {Number} trgTxtIdx     - the index of the target text in texts[] \n *                                   to be compared\n * @param   {Number} srcTkBeginPos - the index of the token in tokens[] \n *                                   at which the comparison should start\n * @param   {Array}  frwReferences - the array of forward references\n * @returns {Match}                - the best match\n */\nSimTexter.prototype._getBestMatch = function(srcTxtIdx, trgTxtIdx, srcTkBeginPos, frwReferences) {\n\tvar self = this,\n\t\t\tbestMatch,\n\t\t\tbestMatchTkPos,\n\t\t\tbestMatchLength = 0,\n\t\t\tsrcTkPos = 0,\n\t\t\ttrgTkPos = 0;\n\t\n\tfor ( var tkPos = srcTkBeginPos;\n\t\t  (tkPos > 0) && (tkPos < self.tokens.length);\n\t\t  tkPos = frwReferences[tkPos]                   ) {\n\t\t\n\t\t// If token not within the range of the target text  \n\t\tif (tkPos < self.texts[trgTxtIdx].tkBeginPos) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvar minMatchLength = (bestMatchLength > 0) ? bestMatchLength + 1 : self.minMatchLength;\n\t\t\n\t\tsrcTkPos = srcTkBeginPos + minMatchLength - 1;\n\t\ttrgTkPos = tkPos + minMatchLength - 1;\n\t\t\n\t\t// Compare backwards\n\t\tif ( srcTkPos < self.texts[srcTxtIdx].tkEndPos &&\n\t\t\t\t trgTkPos < self.texts[trgTxtIdx].tkEndPos && \n\t\t\t \t (srcTkPos + minMatchLength) <= trgTkPos      ) { // check if they overlap\n\t\t\tvar cnt = minMatchLength;\n\t\t\t\n\t\t\twhile (cnt > 0 && self.tokens[srcTkPos].text === self.tokens[trgTkPos].text) {\n\t\t\t\tsrcTkPos--;\n\t\t\t\ttrgTkPos--;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Compare forwards\n\t\tvar newMatchLength = minMatchLength;\n\t\tsrcTkPos = srcTkBeginPos + minMatchLength;\n\t\ttrgTkPos = tkPos + minMatchLength;\n\t\t\n\t\twhile ( srcTkPos < self.texts[srcTxtIdx].tkEndPos &&\n\t\t\t\t\t\ttrgTkPos < self.texts[trgTxtIdx].tkEndPos && \n\t\t\t\t\t\t(srcTkPos + newMatchLength) < trgTkPos    && // check if they overlap\n\t\t\t\t\t\tself.tokens[srcTkPos].text === self.tokens[trgTkPos].text ) {\n\t\t\tsrcTkPos++;\n\t\t\ttrgTkPos++;\n\t\t\tnewMatchLength++;\n\t\t}\n\t\t\n\t\t// Record match\n\t\tif (newMatchLength >= self.minMatchLength && newMatchLength > bestMatchLength) {\n\t\t\tbestMatchLength = newMatchLength;\n\t\t\tbestMatchTkPos  = tkPos;\n\t\t\tbestMatch = new Match(srcTxtIdx, srcTkBeginPos, trgTxtIdx, bestMatchTkPos, bestMatchLength);\n\t\t}\n\t}\n\t\t\t\n\treturn bestMatch;\n};\n\n/**\n * Returns an array of HTML nodes, containing the whole text, \n * together with the hightlighted matches.\n * The text content of each node is retrieved by slicing the input text\n * at the first (txtBeginPos) and the last (txtEndPos) character position \n * of each match.\n * @function\n * @private\n * @param   {Array} inputTexts - the array of {InputText} objects, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t which hold information about each user input\n * @param   {Array} matches    - the array that holds the {MatchSegment} objects, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t stored in pairs\n * @returns {Array}            - the array of HTML nodes, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t which holds the text and the highlighted matches\n */\nSimTexter.prototype._getNodes = function(inputTexts, matches) {\n\tvar self = this,\n\t\t\tiTextsLength = inputTexts.length,\n\t\t\tnodes = [];\n\t\n\tvar styledMatches = self._applyStyles(matches);\n\t\t\n\t// For each input text\n\tfor (var i = 0; i < iTextsLength; i++) {\n\t\tvar inputText = inputTexts[i].text,\n\t\t\t\tchIdx = 0,\n\t\t\t\tchIdxLast = chIdx,\n\t\t\t\tchEndPos = inputText.length,\n\t\t\t\tmIdx = 0,\n\t\t\t\ttrgIdxRef = (i == 0) ? (i + 1) : (i - 1);\n\t\t\t\tnodes[i] = [];\n\t\t\n\t\t// Sort array of similarities\n\t\tvar sortedMatches = self._sortSimilarities(styledMatches, i);\n\n\t\t// For each character position in input text\n\t\twhile (chIdx <= chEndPos) {\n\t\t\tif (sortedMatches.length && mIdx < sortedMatches.length) {\n\t\t\t\tvar match = sortedMatches[mIdx][i];\n\t\t\t\t// Get start character position of match segment\n\t\t\t\tvar mTxtBeginPos = match.getTxtBeginPos(self.tokens);\n\t\t\t\t// Get end character position of match segment\n\t\t\t\tvar mTxtEndPos = match.getTxtEndPos(self.tokens);\n\t\t\t\t\n\t\t\t\t// Create text node\n\t\t\t\tvar textNodeStr = inputText.slice(chIdxLast, mTxtBeginPos);\n\t\t\t\tvar textNode = document.createTextNode(textNodeStr);\n\t\t\t\tnodes[i].push(textNode);\n\t\t\t\t\n\t\t\t\t// Create link node for match segment\n\t\t\t\tvar linkNodeStr = inputText.slice(mTxtBeginPos, mTxtEndPos);\n\t\t\t\tvar linkNode = match.createLinkNode(linkNodeStr, sortedMatches[mIdx][trgIdxRef]);\n\t\t\t\tnodes[i].push(linkNode);\n\t\t\t\t\n\t\t\t\tmIdx++;\n\t\t\t\tchIdx = mTxtEndPos;\n\t\t\t\tchIdxLast = chIdx;\n\t\t\t} else {\n\t\t\t\tvar lastTextNodeStr = inputText.slice(chIdxLast, chEndPos);\n\t\t\t\tvar lastTextNode = document.createTextNode(lastTextNodeStr);\n\t\t\t\tnodes[i].push(lastTextNode);\n\t\t\t\tchIdx = chEndPos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchIdx++;\n\t\t}\n\t}\n\t\n\treturn nodes;\n};\n\n/**\n * Returns an array of matches,\n * where each match is an array of two {MatchSegment} objects, stored in pairs.\n * At index 0, the source {MatchSegment} object is stored,\n * and at index 1, the target {MatchSegment} object.\n * @function\n * @param   {Number} srcTxtIdx     - the index of the source {Text} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in texts[] to be compared\n * @param   {Number} trgTxtIdx     - the index of the target {Text} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in texts[] to be compared\n * @param   {Array}  frwReferences - the array of forward references\n * @returns {Array}                - the array that holds the {MatchSegment} \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t objects, stored in pairs\n */\nSimTexter.prototype._getSimilarities = function(srcTxtIdx, trgTxtIdx, frwReferences) {\n\tvar self         = this,\n\t\t\tsimilarities = [],\n\t\t\tsrcTkPos     = self.texts[srcTxtIdx].tkBeginPos,\n\t\t\tsrcTkEndPos  = self.texts[srcTxtIdx].tkEndPos;\n\n\twhile ((srcTkPos + self.minMatchLength) <= srcTkEndPos) {\n\t\tvar bestMatch = self._getBestMatch(srcTxtIdx, trgTxtIdx, srcTkPos, frwReferences);\n\n\t\tif (bestMatch && bestMatch.matchLength > 0) {\n\t\t\tsimilarities.push([\n\t\t\t\t\tnew MatchSegment(bestMatch.srcTxtIdx, bestMatch.srcTkBeginPos, bestMatch.matchLength), \n\t\t\t\t\tnew MatchSegment(bestMatch.trgTxtIdx, bestMatch.trgTkBeginPos, bestMatch.matchLength)\n\t\t\t\t]);\n\t\t\tsrcTkPos += bestMatch.matchLength;\n\t\t} else {\n\t\t\tsrcTkPos++;\n\t\t}\n\t}\n\t\n\treturn similarities;\n};\n\n/**\n * Creates the forward reference table.\n * @function\n * @private\n * @param {Text}   text          - a {Text} object\n * @param {Array}  frwReferences - the array of forward references \n * @param {Object} mtsTags       - the hash table of minMatchLength \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sequence of tokens (MTS)\n */\nSimTexter.prototype._makeForwardReferences = function(text, frwReferences, mtsTags) {\n\tvar\tself      = this,\n\t\ttxtBeginPos = text.tkBeginPos,\n\t\ttxtEndPos   = text.tkEndPos;\n\t\t\n\t// For each token in tokens[]\n\tfor (var i = txtBeginPos; (i + self.minMatchLength - 1) < txtEndPos; i++) {\n\t\t// Concatenate tokens of minimum match length\n\t\tvar tag = self.tokens.slice(i, i + self.minMatchLength).map(function(token) {\n\t\t\treturn token.text;\n\t\t}).join('');\n\n\t\t// If hash table contains tag\n\t\tif (tag in mtsTags) {\n\t\t\t// Store current token position at index mtsTags[tag]\n\t\t\tfrwReferences[mtsTags[tag]] = i;\n\t\t}\n\t\t// Add tag to hash table and assign current token position to it\n\t\tmtsTags[tag] = i;\n\t}\n};\n\n/**\n * Reads the input string, and initializes texts[] and tokens[].\n * Creates also the forward reference table.\n * @function\n * @private\n * @param {Array} inputTexts    - the array of {InputText} objects\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  that hold information on the user input\n * @param {Array} frwReferences - the array of forward references\n */\nSimTexter.prototype._readInput = function(inputTexts, frwReferences) {\n\tvar self         = this,\n\t    mtsHashTable = {},\n\t    iLength      = inputTexts.length;\n\t\t\n\tfor (var i = 0; i < iLength; i++) {\n\t\tvar inputText = inputTexts[i];\n\t\t// Compute text's words\n\t\tvar nrOfWords = inputText.text.match(/[^\\s]+/g).length;\n\t\t// Initialize texts[]\n\t\tself.texts.push(new Text(inputText.mode, inputText.text.length, nrOfWords, inputText.fileName, self.tokens.length));\n\t\t// Initialize tokens[]\n\t\tself._tokenizeInput(inputText.text);\n\t\t// Update text's last token position\n\t\tself.texts[i].tkEndPos = self.tokens.length;\n\t\t// Create array of forward references\n\t\tself._makeForwardReferences(self.texts[i], frwReferences, mtsHashTable);\n\t}\n};\n\n/**\n * Sorts matches by source or target {MatchSegment},\n * depending on the idx value.\n * @function\n * @private\n * @param   {Array}  matches - the array of matches to be sorted\n * @param   {Number} idx     - the index of the array of \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t the {MatchSegment} objects\n * @returns {Array}          - the sorted array of matches\n */\nSimTexter.prototype._sortSimilarities = function(matches, idx) {\n\tvar sortedSims = matches.slice(0);\n\t\n\tsortedSims.sort(function(a, b) {\n\t\tvar pos = a[idx].tkBeginPos - b[idx].tkBeginPos;\n\t\tif (pos) {\n\t\t\treturn pos;\n\t\t}\n\t\treturn b[idx].matchLength - a[idx].matchLength;\n\t});\n\t\n\treturn sortedSims;\n};\n\n/**\n * Tokenizes the input string.\n * @param {Object} inputText - the input string to be tokenized\n */\nSimTexter.prototype._tokenizeInput = function(inputText) {\n\tvar self        = this,\n\t\t  wordRegex = /[^\\s]+/g,\n\t\t  match;\n\t\n\tvar cleanedText = self._cleanInputText(inputText);\n\t\t\n\twhile (match = wordRegex.exec(cleanedText)) {\n\t\tvar word = match[0];\n\t\tvar token = self._cleanWord(word);\n\t\t\n\t\tif (token.length > 0) {\n\t\t\tvar txtBeginPos = match.index;\n\t\t\tvar txtEndPos   = match.index + word.length;\n\t\t\t// Add token to tokens[]\n\t\t\tself.tokens.push(new Token(token, txtBeginPos, txtEndPos));\n\t\t}\n\t}\n};\n\nmodule.exports = SimTexter;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./match.js\":12,\"./matchSegment.js\":13,\"./text.js\":15,\"./token.js\":16}],15:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Text},\n * which holds information on the input string.\n * @constructor\n * @this  {Text}\n * @param {String} inputMode      - the mode of the input (i.e. 'File' \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tor 'Text')\n * @param {Number} nrOfCharacters - the total number of characters \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tof the input string\n * @param {Number} nrOfWords      - the total number of words \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tof the input string\n * @param {String} fileName       - the name of the file\n * @param {Number} tkBeginPos     - the index (inclusive) of the token\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin {SimTexter.tokens[]}, at which \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tthe input string starts \n * @param {Number} tkEndPos       - the index (non-inclusive) of the token\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  in {SimTexter.tokens[]}, at which \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tthe input string ends \n */\nfunction Text(inputMode, nrOfCharacters, nrOfWords, fileName, tkBeginPos, tkEndPos) {\n\tthis.inputMode      = inputMode;\n\tthis.fileName       = fileName;\n\tthis.tkBeginPos     = tkBeginPos     || 0;\n\tthis.tkEndPos       = tkEndPos       || 0;\n\tthis.nrOfCharacters = nrOfCharacters || 0;\n\tthis.nrOfWords      = nrOfWords      || 0;\n}\n\nmodule.exports = Text;\n\n},{}],16:[function(require,module,exports){\n/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Token}.\n * A {Token} records the starting and ending character position \n * of a word in the input string, to facilitate reconstruction of the input\n * during output of the comparison results.\n * A word is a sequence of characters, \n * separated by one or more whitespaces or newlines.\n * The text of the {Token} corresponds to the \"cleaned\" version of a word. \n * All characters, as defined by the comparison options set by the user,\n * are removed/replaced from the token's text.\n * @constructor\n * @this  {Token}\n * @param {String} text        - the text of the word after being \"cleaned\" \n *                               according to the comparison options \n *                               set by the user \n * @param {Number} txtBeginPos - the index of the word's first character \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (inclusive) in the input string\n * @param {Number} txtEndPos   - the index of the word's last character \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (non-inclusive) in the input string\n */\nfunction Token(text, txtBeginPos, txtEndPos) {\n\tthis.text        = text        || '';\n\tthis.txtBeginPos = txtBeginPos || 0;\n\tthis.txtEndPos   = txtEndPos   || 0;\n}\n\nmodule.exports = Token;\n\n},{}]},{},[11])\n\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $               = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar FileInputReader = require('../inputReader/fileInputReader.js');\nvar InputText       = require('./inputText.js');\nvar SimTexter       = require('../simtexter/simtexter.js');\nvar TextInputReader = require('../inputReader/textInputReader.js');\n\n/**\n * Creates an instance of a {Controller}, \n * which handles user interaction (data reading, input control, comparison).\n * Interacts with the {View} object to render the final output.\n * @constructor\n * @this  {Controller}\n * @param {Storage} storage - the object that holds the app's settings \n * @param {View}    view    - the app's view\n */\nfunction Controller(storage, view) {\n\tthis.storage              = storage;\n\tthis.view                 = view;\n\tthis.maxCharactersPerPage = 1900;\n\tthis.maxNumberOfPages     = 500;\n\tthis.inputTexts           = [ new InputText(), new InputText() ];\n\t\n\tthis._bindEvents();\n\tthis._updateUI(this.storage.data);\n}\n\n/**\n * Displays a warning message if input is too long (> maxNumberOfPages).\n * @function\n * @private\n * @param {Number} idx - the index of the {InputText} object in inputTexts[]\n */\nController.prototype._alertLongInput = function(idx) {\n\tvar self = this;\n\t\n\t// Compute approximate number of pages for inputText\n\tvar nrOfPages = self.inputTexts[idx].getNumberOfPages(self.maxCharactersPerPage);\n\t// If greater than maximum number of pages, display warning message\n\tif (nrOfPages > self.maxNumberOfPages) {\n\t\tvar inputMode = self.inputTexts[idx].mode;\n\t\tvar message = [\n\t\t\t\tinputMode, ' ', (idx + 1), ' is too long. To prevent visualization issues, please consider truncating this ', inputMode.toLowerCase(), '.' \n\t\t\t].join('');\n\t\tvar delay = self._computeReadingSpeed(message);\n\t\tself.view.showAlertMessage('warning', message, delay);\n\t}\n};\n\n/**\n * Binds events.\n * @function\n * @private\n */\nController.prototype._bindEvents = function() {\n\tvar self = this;\n\t\n\tself.view.bind('changeSpinnerInput', function(id, newValue) {\n\t\tself._updateStorage(id, newValue);\n\t});\n\t\n\tself.view.bind('compare', function() {\n\t\tself._compare();\n\t});\n\t\n\tself.view.bind('dismissAlert');\n\tself.view.bind('hidePrintDialog');\n\tself.view.bind('initBootstrap');\n\t\n\tself.view.bind('inputFile', function(file, idx, loadingElem, tabPaneId) {\n\t\tself._readFile(file, idx, loadingElem, tabPaneId);\n\t});\n\t\n\tself.view.bind('inputText', function(text, idx, tabPaneId) {\n\t\tself._readText(text, idx, tabPaneId);\n\t});\n\t\n\tself.view.bind('print', function(hideModalPromise) {\n\t\tself._print(hideModalPromise);\n\t});\n\t\n\tself.view.bind('resize');\n\tself.view.bind('scrollToMatch');\n\tself.view.bind('selectTab');\n\t\n\tself.view.bind('selectHTMLOption', function(idx, newValue, text) {\n\t\tself.inputTexts[idx].setHTMLOption(newValue);\n\t\tif (text) {\n\t\t\tself._readText(text, idx, self.inputTexts[idx].tabPaneId);\n\t\t}\n\t});\n\t\n\tself.view.bind('selectSettingsOption', function(id, newValue) {\n\t\tself._updateStorage(id, newValue);\n\t});\n\t\n\tself.view.bind('showPrintDialog');\n\tself.view.bind('toggleInputPanel');\n\tself.view.bind('toggleSettingsSidebar');\n\tself.view.bind('toggleSettingsSidebarPanes');\n};\n\n/**\n * Initiates the comparison process.\n * @function\n * @private\n */\nController.prototype._compare = function() {\n\tvar self = this;\n\t\n\tif (self._isInputValid()) {\n\t\tself.view.toggleWaitingCursor('show');\n\t\tvar simtexter = new SimTexter(self.storage);\n\t\t\n\t\tsetTimeout(function() {\n\t\t\tsimtexter.compare(self.inputTexts).then(\n\t\t\t\t// On success, update information nodes and display similarities\n\t\t\t\tfunction(nodes) {\n\t\t\t\t\tself.view.results = {\n\t\t\t\t\t\ttexts         : simtexter.texts,\n\t\t\t\t\t\tuniqueMatches : simtexter.uniqueMatches\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tself.view.createTemplates();\n\t\t\t\t\tself.view.showSimilarities(nodes);\n\t\t\t\t\tself.view.resetScrollbars();\n\t\t\t\t},\n\t\t\t\t// On error, clear output panel and display warning message\n\t\t\t\tfunction(message) {\n\t\t\t\t\tself.view.clearOutputPanel();\n\t\t\t\t\tvar delay = self._computeReadingSpeed(message);\n\t\t\t\t\tself.view.showAlertMessage('info', message, delay);\n\t\t\t\t}\n\t\t\t);\n\t\t}, 200);\n\t}\n};\n\n/**\n * Returns the amount of time in milliseconds\n * that a user needs in order to read a message.\n * @function\n * @private\n * @param {String} message - the message to be read\n */\nController.prototype._computeReadingSpeed = function(message) {\n\tvar minMS = 6000;\n\tvar speed = Math.round(message.length / 40) * 4000;\n\treturn (speed > minMS) ? speed : minMS;\n};\n\n/**\n * Checks if the user has provided a valid input\n * in both source and target input panes.\n * If not, the user is prompted.\n * @function\n * @private\n * @returns {Boolean} - true if input is valid, else false.\n */\nController.prototype._isInputValid = function() {\n\tvar self = this,\n\t\t\tisValid = true,\n\t\t\tactiveTabPaneIds = self.view.getActiveTabPaneIds(),\n\t\t\tiTextsLength = self.inputTexts.length;\n\t\n\tfor (var i = 0; i < iTextsLength; i++) {\n\t\tvar inputText = self.inputTexts[i];\n\t\tvar activeTabPaneId = activeTabPaneIds[i];\n\t\t\n\t\tvar isInputTextValid = (inputText.text !== undefined && inputText.tabPaneId === activeTabPaneId);\n\t\t\n\t\tif (!isInputTextValid) {\n\t\t\tself.view.toggleErrorStatus('show', activeTabPaneId);\n\t\t} else {\n\t\t\tself.view.toggleErrorStatus('hide', activeTabPaneId);\n\t\t}\n\t\t\n\t\tisValid = isValid && isInputTextValid;\n\t}\n\t\n\treturn isValid;\n};\n\n/**\n * Sends the contents of the current window\n * to the system's printer for printing. \n * @function\n * @private\n * @param {Promise} hideModalPromise - a promise that handles the hiding \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t of the 'PRINT OUTPUT' dialog. \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t When resolved, the current window \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is sent to printing.\n */\nController.prototype._print = function(hideModalPromise) {\n\tvar success = function() {\n\t\tsetTimeout(function() {\n\t\t\twindow.print();\n\t\t}, 700);\n\t};\n\t\n\t$.when(hideModalPromise).then(success);\n};\n\n/**\n * Extracts the contents of the selected file\n * and updates the relevant fields of the {InputText} object.\n * @function\n * @private\n * @param {FileList} file        - the file selected by the user\n * @param {Number}   idx         - the index of the {InputText} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in inputTexts[] to be updated.\n *                                 0: input in left-side pane \n *                                 1: input in right-side pane\n * @param {Object}   loadingElem - the node element that shows \n *                                 the progress of reading  \n * @param {String}   tabPaneId   - the id of the active tab pane\n */\nController.prototype._readFile = function(file, idx, loadingElem, tabPaneId) {\n\tvar self = this,\n\t    ignoreFootnotes = self.storage.getItemValueByKey('ignoreFootnotes');\n\t    \n\tvar success = function(text) {\n\t\t\t// Update {InputText} object\n\t\t\tself.inputTexts[idx].setFileInput(file, text, tabPaneId);\n\t\t\tself.view.loading('done', loadingElem);\n\t\t\tself.view.clearTabPaneTextInput(idx);\n\t\t\tself._alertLongInput(idx);\n\t\t};\n\t\t\n\t\tvar error = function(message) {\n\t\t\tself.inputTexts[idx].reset();\n\t\t\tself.view.loading('error', loadingElem);\n\t\t\tself.view.clearTabPaneTextInput(idx);\n\t\t\t\n\t\t\tvar delay = self._computeReadingSpeed(message);\n\t\t\tself.view.showAlertMessage('error', message, delay);\n\t\t};\n\t\n\tif (file) {\n\t\tvar loadingStarted = self.view.loading('start', loadingElem);\n\t\tvar fileInputReader = new FileInputReader(file, ignoreFootnotes);\n\t\tfileInputReader.readFileInput(loadingStarted).then(success, error);\n\t} else {\n\t\tself.view.loading('cancel', loadingElem);\n\t\tself.inputTexts[idx].reset();\n\t}\n};\n\n/**\n * Extracts the contents of the typed/pasted HTML/plain text\n * and updates the relevant fields of the {InputText} object.\n * @function\n * @private\n * @param {String} text      - the HTML/plain text provided by the user\n * @param {Number} idx       - the index of the {InputText} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t in inputTexts[] to be updated.\n *                             0: input in left-side pane, \n *                             1: input in right-side pane\n * @param {String} tabPaneId - the id of the active tab pane\n */\nController.prototype._readText = function(text, idx, tabPaneId) {\n\tvar self = this;\n\t\n\tvar success = function(cleanedText) {\n\t\t// Update {InputText} object\n\t\tself.inputTexts[idx].setTextInput(cleanedText, tabPaneId);\n\t\tself.view.toggleCompareBtn('enable');\n\t\tself.view.clearTabPaneFileInput(idx);\n\t\tself._alertLongInput(idx);\n\t};\n\t\n\tvar error = function(message) {\n\t\tself.inputTexts[idx].reset();\n\t\tself.view.toggleCompareBtn('enable');\n\t\tvar delay = self._computeReadingSpeed(message);\n\t\tself.view.showAlertMessage('error', message, delay);\n\t};\n\t\n\tif (text.length > 0 && /\\S/.test(text)) {\n\t\tif (self.inputTexts[idx].isHTML) {\n\t\t\tself.view.toggleCompareBtn('disable');\n\t\t\tvar textInputReader = new TextInputReader();\n\t\t\ttextInputReader.readTextInput(text).then(success, error);\n\t\t} else {\n\t\t\tsuccess(text);\n\t\t}\n\t} else {\n\t\tself.inputTexts[idx].reset();\n\t}\n};\n\n/**\n * Updates the value of a setting, stored in the {Storage} object.\n * @function\n * @private\n * @param {String}           id       - the id of the setting\n * @param {(Boolean|Number)} newValue - the new value of the setting\n */\nController.prototype._updateStorage = function(id, newValue) {\n\tvar self = this;\n\tself.storage.setItemValueById(id, newValue);\n};\n\n/**\n * Updates the {View} object with the values of the settings,\n * stored in the {Storage} object.\n * @function\n * @private\n * @param {Object} data - the object that holds the storage's settings\n */\nController.prototype._updateUI = function(data) {\n\tvar self = this;\n\t\n\tfor (var key in data) {\n\t\tvar obj = data[key];\n\t\tself.view.updateUIOption(obj.id, obj.type, obj.value);\n\t}\n};\n\nmodule.exports = Controller;","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {InputText},\n * which holds information on the user input.\n * @constructor\n * @this  {InputText}\n * @param {String} mode      - the mode of input (i.e. \"file\" or \"text\")\n * @param {File}   file      - the file selected by the user\n * @param {String} text      - the input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nfunction InputText(mode, file, text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = mode;\n\tthis.isHTML     = false;\n\tthis.fileName   = (file && file.name);\n\tthis.text       = text;\n}\n\n/**\n * Returns the approximate number of pages of the input string.\n * @function\n * @param   {Number} maxCharactersPerPage - the maximum number of characters \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tper page\n * @returns {Number}                      - the ca. number of pages\n */\nInputText.prototype.getNumberOfPages = function(maxCharactersPerPage) {\n\treturn (this.text.length / maxCharactersPerPage);\n};\n\n/**\n * Resets some fields of the {InputText}.\n * @function\n */\nInputText.prototype.reset = function() {\n\tthis.tabPaneId  = undefined;\n\tthis.mode       = undefined;\n\tthis.fileName   = undefined;\n\tthis.text       = undefined;\n};\n\n/**\n * Sets the fields for the file input.\n * @function\n * @param {File}   file      - the file selected by the user\n * @param {String} text      - the file input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nInputText.prototype.setFileInput = function(file, text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = 'File';\n\tthis.fileName   = file.name;\n\tthis.text       = text;\n};\n\n/**\n * Sets the fields for the text input.\n * @function\n * @param {String} text      - the text input string\n * @param {String} tabPaneId - the id of the tab pane\n */\nInputText.prototype.setTextInput = function(text, tabPaneId) {\n\tthis.tabPaneId  = tabPaneId;\n\tthis.mode       = 'Text';\n\tthis.fileName   = (this.isHTML) ? 'HTML text input' : 'Plain text input';\n\tthis.text       = text;\n};\n\nInputText.prototype.setHTMLOption = function(newValue) {\n\tthis.isHTML = newValue;\n};\n\nmodule.exports = InputText;","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Storage},\n * which stores the values of the app's settings.\n * If local storage is supported by the browser,\n * these settings are also stored under the specified namespace,\n * thus providing the app with a state.\n * The last stored settings will be restored \n * when refreshing the page or restarting the browser. \n * @constructor\n * @this  {Storage}\n * @param {String} namespace - the namespace of the app (i.e. \"simtexter\")\n * @param {Object} data      - the object that holds the app's settings\n */\nfunction Storage(namespace, data) {\n\t this._db  = namespace;\n\t this.data = this._initialize(namespace, data);\n}\n\n/**\n * Returns the value of a setting, retrieved by its key value.\n * @function\n * @param {String} key - the key value of the setting\n */\nStorage.prototype.getItemValueByKey = function(key) {\n\tvar self = this;\n\treturn self._getItemByKey(key).value;\n};\n\n/**\n * Sets the new value of a setting, retrieved by its id value.\n * @function\n * @param {String}           id       - the id of the setting\n * @param {(Boolean|Number)} newValue - the new value of the setting\n */\nStorage.prototype.setItemValueById = function(id, newValue) {\n\tvar self = this,\n\t    item = self._getItemById(id);\n\t\n\titem.value = newValue;\n\tself._save(self.data);\n};\n\n/**\n * Retrieves a setting by its id value.\n * @function\n * @private\n * @param {String} id - the id of the setting\n */\nStorage.prototype._getItemById = function(id) {\n\tvar self = this,\n\t    data = self.data;\n\t\n\tfor (var key in data) {\n\t\tvar obj = data[key];\n\t\tif (obj.id === id) {\n\t\t\treturn obj;\n\t\t}\n\t}\n\t\n\treturn undefined;\n};\n\n/**\n * Retrieves a setting by its key value.\n * @function\n * @private\n * @param {String} key - the key value of the setting\n */\nStorage.prototype._getItemByKey = function(key) {\n\tvar self = this;\n\treturn self.data[key];\n};\n\n/**\n * Stores the app's settings in the web browser's local storage\n * under the specified namespace.\n * If local storage is not supported, stores the settings\n * in {Storage.data}.\n * @function\n * @private\n * @param {String} namespace - the namespace of the app\n * @param {Object} data      - the object that holds the app's settings\n */\nStorage.prototype._initialize = function(namespace, data) {\n\tif (localStorage) {\n\t\tif (!localStorage[namespace]) {\n\t\t\tlocalStorage.setItem(namespace, JSON.stringify(data));\n\t\t} else {\n\t\t\tvar store = localStorage.getItem(namespace);\n\t\t\treturn JSON.parse(store);\n\t\t}\n\t}\n\t\n\treturn data;\n};\n\n/**\n * Stores the settings in the local storage.\n * @function\n * @private\n * @param {Object} data - the data (settings) to be updated\n */\nStorage.prototype._save = function(data) {\n\tif (localStorage && localStorage[this._db]) {\n\t\tlocalStorage.setItem(this._db, JSON.stringify(data));\n\t}\n\tthis.data = data;\n};\n\nmodule.exports = Storage;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Template},\n * which appends node elements in the DOM or updates their inner content. \n * @constructor\n * @this {Template}\n */\nfunction Template() {\n}\n\n/**\n * Returns the node element of the template\n * for displaying warning messages.\n * @function\n * @param   {String} type    - the type of warning\n * @param   {String} message - the text of the warning message\n * @returns {Object}         - the top node element\n */\nTemplate.prototype.createAlertMessage = function(type, message) {\n\tvar div = document.createElement('div');\n\t\t\n\tdiv.className = 'alert alert-warning';\n\tdiv.innerHTML = [\n\t\t\t'<table class=\"table table-condensed\">',\n\t\t\t\t'<tbody>',\n\t\t\t\t\t'<tr>',\n\t\t\t\t\t\t'<td class=\"h5\"><i class=\"fa fa-exclamation-circle\"></i></td>',\n\t\t\t\t\t\t'<td>',\n\t\t\t\t\t\t\t'<h5>', type, '</h5>',\n\t\t\t\t\t\t\t'<p>', message, '</p>',\n\t\t\t\t\t\t'</td>',\n\t\t\t\t\t'</tr>',\n\t\t\t\t'</tbody>',\n\t\t\t'</table>'\n\t\t].join('');\n\t\t\n\treturn div;\n};\n\n/**\n * Updates the inner HTML content of the output titles.\n * @function\n * @param {Array} texts - the array that holds information about the user input\n */\nTemplate.prototype.createOutputTitles = function(texts) {\n\tvar targets = [ document.getElementById('output-title-1'), document.getElementById('output-title-2') ],\n\t    tLength = targets.length;\n\t\t\n\tfor (var i = 0; i < tLength; i++) {\n\t\tvar fileName = texts[i].fileName || '';\n\t\tvar mode     = texts[i].inputMode;\n\t\tvar target   = targets[i];\n\t\ttarget.innerHTML = [\n\t\t\t\t'<p><b>', mode.toUpperCase(), ': </b>', fileName, '</p> ',\n\t\t\t].join('');\n\t}\n};\n\n/**\n * Returns the node element of the template\n * for displaying the \"PRINT OUTPUT\" dialog.\n * @function\n * @param   {Array} texts - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\tabout the user input\n * @returns {Object}      - the top node element\n */\nTemplate.prototype.createPrintDialog = function(texts) {\n\tvar section = document.createElement('section');\n\t\n\tsection.id = 'modal-print';\n\tsection.className = 'modal fade';\n\tsection.setAttribute('tabindex', '-1');\n\tsection.setAttribute('role', 'dialog');\n\tsection.innerHTML = [\n\t\t\t'<div class=\"modal-dialog\">',\n\t      '<div class=\"modal-content\">',\n          '<div class=\"modal-header\">',\n            '<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">',\n              '<span aria-hidden=\"true\">&times;</span>',\n            '</button>',\n            '<h4 class=\"modal-title\">Print output</h4>',\n          '</div>',\n          '<div class=\"modal-body\">',\n            '<div class=\"row\">',\n              '<div class=\"col-xs-6\">',\n                '<div class=\"form-group form-group-sm\">',\n                  '<label for=\"input-comment-1\">1: Comment for ', texts[0].inputMode, '</label>',\n                  '<textarea id=\"input-comment-1\" class=\"form-control\" rows=\"5\" autocomplete=\"off\" placeholder=\"Type a comment\"></textarea>',\n                '</div>',\n              '</div>',\n              '<div class=\"col-xs-6\">',\n                '<div class=\"form-group form-group-sm\">',\n                  '<label for=\"input-comment-2\">2: Comment for ', texts[1].inputMode, '</label>',\n                  '<textarea id=\"input-comment-2\" class=\"form-control\" rows=\"5\" autocomplete=\"off\" placeholder=\"Type a comment\"></textarea>',\n                '</div>',\n              '</div>',\n            '</div>',\n          '</div>',\n          '<div class=\"modal-footer\">',\n            '<button type=\"button\" class=\"btn btn-default btn-sm\" data-dismiss=\"modal\">Cancel</button>',\n            '<button id=\"modal-print-btn\" type=\"button\" class=\"btn btn-primary btn-sm\">Print</button>',\n          '</div>',\n\t      '</div>',\n      '</div>'\n\t\t].join('');\n\t\t\n\treturn section;\n};\n\n/**\n * Updates the inner HTML content of the hidden, on screen, node element\n * that holds the information (statistics & comments) to be printed.\n * @function\n * @param {Array}  texts         - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t about the user input\n * @param {Number} uniqueMatches - the number of the unique matches found\n */\nTemplate.prototype.createPrintSummary = function(texts, uniqueMatches) {\n\tvar target = document.getElementById('print-summary');\n\t\t\n\ttarget.innerHTML = [\n\t\t\t'<h4>COMPARISON SUMMARY</h4>',\n\t\t\t'<h6>DATE/TIME: ', (new Date()).toUTCString(), '</h6>',\n\t\t  '<table class=\"table table-condensed table-bordered\">',\n\t      '<thead>',\n\t        '<tr>',\n\t          '<th class=\"col-xs-2\"></th>',\n\t          '<th class=\"col-xs-5\">', texts[0].fileName, '</th>',\n\t          '<th class=\"col-xs-5\">', texts[1].fileName, '</th>',\n\t        '</tr>',\n\t      '</thead>',\n\t      '<tbody>',\n\t      \t'<tr>',\n\t          '<th>Comment</th>',\n\t          '<td id=\"print-comment-1\"></td>',\n\t          '<td id=\"print-comment-2\"></td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Type</th>',\n\t          '<td>', texts[0].inputMode, '</td>',\n\t          '<td>', texts[1].inputMode, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Characters</th>',\n\t          '<td>', texts[0].nrOfCharacters, '</td>',\n\t          '<td>', texts[1].nrOfCharacters, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Words</th>',\n\t          '<td>', texts[0].nrOfWords, '</td>',\n\t          '<td>', texts[1].nrOfWords, '</td>',\n\t        '</tr>',\n\t        '<tr>',\n\t          '<th>Unique matches</th>',\n\t          '<td colspan=\"2\">', uniqueMatches, '</td>',\n\t        '</tr>',\n\t      '</tbody>',\n\t\t  '</table>'\n\t\t].join('');\n};\n\n/**\n * Updates the inner HTML content\n * of the node element that holds the statistical data. \n * @function\n * @param {Array}  texts         - the array that holds information \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t about the user input\n * @param {Number} uniqueMatches - the number of the unique matches found\n */\nTemplate.prototype.createStatistics = function(texts, uniqueMatches) {\n\tvar target = document.getElementById('statistics');\n\t\t\n\ttarget.innerHTML = [\n\t\t  '<table class=\"table table-condensed table-bordered\">',\n\t      '<thead>',\n          '<tr>',\n            '<th class=\"col-xs-2\"></th>',\n            '<th class=\"col-xs-5\">', texts[0].fileName, '</th>',\n            '<th class=\"col-xs-5\">', texts[1].fileName, '</th>',\n          '</tr>',\n\t      '</thead>',\n\t      '<tbody>',\n          '<tr>',\n            '<th>Type</th>',\n            '<td>', texts[0].inputMode, '</td>',\n            '<td>', texts[1].inputMode, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Characters</th>',\n            '<td>', texts[0].nrOfCharacters, '</td>',\n            '<td>', texts[1].nrOfCharacters, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Words</th>',\n            '<td>', texts[0].nrOfWords, '</td>',\n            '<td>', texts[1].nrOfWords, '</td>',\n          '</tr>',\n          '<tr>',\n            '<th>Unique matches</th>',\n            '<td colspan=\"2\">', uniqueMatches, '</td>',\n          '</tr>',\n\t      '</tbody>',\n\t\t  '</table>'\n\t\t].join('');\n};\n\nmodule.exports = Template;","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $           = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar TargetMatch = require('../autoScroll/targetMatch.js');\n\n/**\n * Creates an instance of a {View},\n * which implements all the UI logic of the application.\n * @constructor\n * @this  {View}\n * @param {Template} template - the object that appends/updates elements \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the DOM\n */\nfunction View(template) {\n\tthis.template = template;\n\tthis.results  = {};\n\t\n\t// Selectors\n\tthis.$alertsPanel          = $('#alerts-panel');\n\tthis.$compareBtn           = $('#compare-btn');\n\tthis.$contentWrapper       = $('#content-wrapper');\n\tthis.$file                 = $(':file');\n\tthis.$htmlOptions          = $('#html-text-1, #html-text-2');\n\tthis.$inputLnk             = $('#input-lnk');\n\tthis.$inputPanel           = $('#input-panel');\n\tthis.$inputPanes           = $('#input-pane-1, #input-pane-2');\n\tthis.$inputFiles           = $('#input-file-1, #input-file-2');\n\tthis.$inputTexts           = $('#input-text-1, #input-text-2');\n\tthis.$outputPanel          = $('#output-panel');\n\tthis.$outputTexts          = $('#comparison-output-1, #comparison-output-2');\n\tthis.$outputTextContainers = $('#comparison-output-1 > .comparison-output-container, #comparison-output-2 > .comparison-output-container');\n\tthis.$outputParagraphs     = $('#comparison-output-1 > .comparison-output-container > p, #comparison-output-2 > .comparison-output-container > p');\n\tthis.$printBtn             = $('#print-btn');\n\tthis.$settingsSidebar      = $('#settings-sidebar');\n\tthis.$settingsSidebarLnk   = $('#settings-sidebar-lnk');\n\tthis.$settingsSidebarPanes = $('#comparison-options-pane, #input-options-pane');\n\tthis.$spinner              = $('#min-match-length-spinner');\n\tthis.$tooltip              = $('[data-toggle=\"tooltip\"], [rel=\"tooltip\"]');\n\t\n\tthis._resetTextInputTabPanes();\n\tthis._updateOutputPanelHeight();\n\tthis._updateAlertsPanelWidth();\n}\n\n/**\n * Binds events depending on the name specified.\n * @function\n * @param {String} event     - the name of the event\n * @param {Function} handler - the callback function\n */\nView.prototype.bind = function(event, handler) {\n\tvar self = this;\n\t\n\tswitch (event) {\n\t\tcase 'changeSpinnerInput':\n\t\t\tself.$spinner\n\t\t\t\t.on('change mousewheel DOMMouseScroll', 'input[type=\"text\"]', function(e) {\n\t\t\t\t\t\tvar elem = e.target;\n\t\t\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t  \t\tvar minMatchLength = parseInt($(elem).val(), 10);\n\t\t\t\t  \t\t\n\t\t\t\t  \t\tif (e.type === 'mousewheel' || e.type === 'DOMMouseScroll') {\n\t\t\t\t\t  \t\t// scrolling up\n\t\t\t\t  \t\t\tif (e.originalEvent.wheelDelta > 0 || e.originalEvent.detail < 0) {\n\t\t\t\t\t\t        minMatchLength += 1;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    // scrolling down\n\t\t\t\t\t\t    else {\n\t\t\t\t\t\t        minMatchLength -= 1;\n\t\t\t\t\t\t    }\n\t\t\t\t  \t\t}\n\t\t\t\t  \t\t\n\t\t\t\t  \t\tminMatchLength = (minMatchLength < 1) ? 1 : minMatchLength; \n\t\t\t\t\t\t\n\t\t\t\t\t\thandler(id, minMatchLength);\n\t\t\t\t    \tself.updateUIOption(id, 'inputText', minMatchLength);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.on('click', '.btn', function(e) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\n\t\t\t\t\tvar $elem = $(e.delegateTarget).find('input[type=\"text\"]');\n\t\t\t\t\tvar id = self._getId($elem);\n\t\t  \t\tvar minMatchLength = parseInt($elem.val(), 10);\n\t\t\t\t\t\n\t\t\t\t\tif ($(e.currentTarget).hasClass('plus')) {\n\t\t\t\t\t\tminMatchLength += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminMatchLength = (minMatchLength > 1) ? (minMatchLength - 1) : minMatchLength;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\thandler(id, minMatchLength);\n\t\t\t\t    self.updateUIOption(id, 'inputText', minMatchLength);\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'compare':\n\t\t\tself.$compareBtn.on('click', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself.$settingsSidebar.removeClass('expanded');\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\thandler();\n\t\t\t\t}, 200);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'dismissAlert':\n\t\t\tself.$alertsPanel.on('click', '.alert', function() {\n\t\t\t\t$(this).remove();\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'initBootstrap':\n\t\t\tself.$tooltip.tooltip({\n\t\t\t\tcontainer : 'body',\n\t\t\t\tdelay     : { \"show\": 800, \"hide\": 0 },\n\t\t\t\thtml      : true,\n\t\t\t\tplacement : 'bottom',\n\t\t\t\ttrigger   : 'hover'\n\t\t\t});\n\t\t\t\n\t\t\tself.$file.filestyle({\n\t\t\t\tbuttonName  : \"btn-primary\",\n\t\t\t\tbuttonText  : \"Browse file\",\n\t\t\t\tplaceholder : \"No file selected\",\n\t\t\t\tsize        : \"sm\"\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'inputFile':\n\t\t\tself.$inputFiles.on('change', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t\n\t\t\t\tvar tabPaneId = self._getId($(elem).parents('.tab-pane'));\n\t\t\t\tself.toggleErrorStatus('hide', tabPaneId);\n\t\t\t\t\n\t\t\t\tvar file = elem.files[0];\n\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\tvar loadingElem = $(elem).parent();\n\t\t\t\thandler(file, idx, loadingElem, tabPaneId);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'inputText':\n\t\t\tself.$inputTexts.on('change input', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar $elem = $(elem);\n\t\t\t\tvar tabPaneId = self._getId($elem.parents('.tab-pane'));\n\t\t\t\t\n\t\t\t\tif (e.type === 'input') {\n\t\t\t\t\tself.toggleErrorStatus('hide', tabPaneId);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e.type === 'change') {\n\t\t\t\t\tvar id = self._getId(elem);\n\t\t\t\t\tvar text = $elem.val();\n\t\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\t\thandler(text, idx, tabPaneId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'hidePrintDialog':\n\t\t\tself.$contentWrapper.on('hide.bs.modal', '.modal', function(e) {\n\t\t\t\tself._togglePrintDialog('hide', e.target);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'print':\n\t\t\tself.$contentWrapper.on('click', '#modal-print-btn', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\tvar inputComment1  = $('#input-comment-1').val();\n\t\t\t\tvar inputComment2  = $('#input-comment-2').val();\n\t\t\t\t$('#print-comment-1').text(inputComment1);\n\t\t\t\t$('#print-comment-2').text(inputComment2);\n\t\t\t\t\n\t\t\t\tvar hideModalPromise = $('.modal').modal('hide').promise();\n\t\t\t\thandler(hideModalPromise);\n\t\t\t});\n\t\t\tbreak;\n\t\t\n\t\tcase 'resize':\n\t\t\t$(window).on('resize', function() {\n\t\t\t\tself._updateOutputPanelHeight();\n\t\t\t\tself._updateAlertsPanelWidth();\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'scrollToMatch':\n\t\t\tself.$outputTexts.on('click', 'a', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t\n\t\t\t\tvar targetMatch = new TargetMatch(e.target);\n\t\t\t\tvar scrollPosition = targetMatch.getScrollPosition();\n\t\t\t\ttargetMatch.scroll(scrollPosition);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectHTMLOption':\n\t\t\tself.$inputPanel.on('change', 'input[type=\"checkbox\"]', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\tvar idx = self._getIndex(id);\n\t\t\t\tvar newValue = $(elem).prop('checked');\n\t\t\t\tvar text = self.$inputTexts.eq(idx).val();\n\t\t\t\thandler(idx, newValue, text);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectSettingsOption':\n\t\t\tself.$settingsSidebarPanes.on('change', 'input[type=\"checkbox\"]', function(e) {\n\t\t\t\tvar elem = e.target;\n\t\t\t\tvar id = self._getId(elem);\n\t\t\t\tvar newValue = $(elem).prop('checked');\n\t\t\t\thandler(id, newValue);\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'selectTab':\n\t\t\tself.$inputPanes.on('shown.bs.tab', 'a[data-toggle=\"tab\"]', function(e) {\n\t\t\t\tvar lastTabPaneId = $(e.relatedTarget).attr('href');\n\t\t\t\tself.toggleErrorStatus('hide', lastTabPaneId);\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'showPrintDialog':\n\t\t\tself.$printBtn.on('click', function(e) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tself._togglePrintDialog('show');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleInputPanel':\n\t\t\tself.$inputLnk.on('click', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t// Hide tooltip (if any)\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself._toggleInputPanel('toggle');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleSettingsSidebar':\n\t\t\tself.$settingsSidebarLnk.on('click', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\t// Hide tooltip (if any)\n\t\t\t\t$(this).tooltip('hide');\n\t\t\t\tself.$settingsSidebar.toggleClass('expanded');\n\t\t\t});\n\t\t\n\t\t\t// Hide settings sidebar when clicking inside the 'nav' and '#content-wrapper' elements\n\t\t\t$('body').on('click', 'nav, #content-wrapper', function() {\n\t\t\t\tself.$settingsSidebar.removeClass('expanded');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'toggleSettingsSidebarPanes':\n\t\t\tself.$settingsSidebar.on('click', '.panel-title', function() {\n\t\t\t\t$(this).toggleClass('active');\n\t\t\t});\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Removes all <p> nodes from each output pane\n * and hides the output panel.\n * @function\n */\nView.prototype.clearOutputPanel = function() {\n\tvar self = this;\n\t\n\tself.$outputParagraphs.each(function() {\n\t\t$(this).remove();\n\t});\n\tself._toggleOutputPanel('hide');\n\tself.toggleWaitingCursor('hide');\n};\n\n/**\n * Clears all input from the \"FILE\" tab pane.\n * @function\n * @param {Number} idx - the number of the tab pane\n *                       0: for left-side pane, 1: for right-side pane\n */\nView.prototype.clearTabPaneFileInput = function(idx) {\n\tvar self = this;\n\tvar tabPaneId = '#tab-file-' + (idx + 1);\n\t$(tabPaneId + ' input').filestyle('clear');\n\tself.toggleErrorStatus('hide', tabPaneId);\n\tself.loading('cancel', tabPaneId);\n};\n\n/**\n * Clears all input from the \"TEXT\" tab pane.\n * @function\n * @param {Number} idx - the number of the tab pane\n *                       0: for left-side pane, 1: for right-side pane\n */\nView.prototype.clearTabPaneTextInput = function(idx) {\n\tvar self = this;\n\tvar tabPaneId = '#tab-text-' + (idx + 1);\n\t$(tabPaneId + ' textarea').val('');\n\tself.toggleErrorStatus('hide', tabPaneId);\n};\n\n/**\n * Creates the node templates.\n * @function\n */\nView.prototype.createTemplates = function() {\n\tvar self = this;\n\tself.template.createPrintSummary(self.results.texts, self.results.uniqueMatches);\n\tself.template.createStatistics(self.results.texts, self.results.uniqueMatches);\n\tself.template.createOutputTitles(self.results.texts);\n};\n\n/**\n * Returns the ids of active tab panes as an array of strings.\n * @function\n * @returns {Array<String>} - the ids of the active tab panes\n */\nView.prototype.getActiveTabPaneIds = function() {\n\tvar self = this,\n\t\ttabPaneIds = [];\n\t\t\n\t$('.tab-pane.active').each(function() {\n\t\tvar tabPaneId = self._getId(this);\n\t\ttabPaneIds.push(tabPaneId);\n\t});\n\treturn tabPaneIds;\n};\n\n/**\n * Shows/hides an node element depending on the event specified.\n * Used to show the progress of a process (e.g. input reading).\n * @function\n * @param {String} event  - the name of the event\n * @param {Object} target - the id of the node element\n */\nView.prototype.loading = function(event, target) {\n\tvar self = this;\n\t\n\tswitch (event) {\n\t\tcase 'start':\n\t\t\tself.toggleCompareBtn('disable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-spinner').removeClass('hidden');\n\t\t\tbreak;\n\t\t\n\t\tcase 'done':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-check').removeClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'cancel':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'error':\n\t\t\tself.toggleCompareBtn('enable');\n\t\t\t$(target).find('.fa').addClass('hidden');\n\t\t\t$(target).find('.fa-times').removeClass('hidden');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Resets the scroll bars.\n * @function\n */\nView.prototype.resetScrollbars = function() {\n\tvar self = this;\n\tself.$outputTexts.scrollTop(0);\n};\n\n/**\n * Clears text from textarea and unchecks checkboxes.\n * Important for Internet Explorer, \n * since it does not recognize the \"autocomplete='off'\" attribute.\n * @function\n * @private\n */\nView.prototype._resetTextInputTabPanes = function() {\n\tvar self = this;\n\tself.$htmlOptions.prop('checked', false);\n\tself.$inputTexts.val('');\n};\n\n/**\n * Displays a warning message.\n * @function\n * @param {String} type    - the type of the message\n * @param {String} message - the text of the message\n * @param {Number} delay   - the time in milliseconds, during which the message \n *                           should remain visible\n */\nView.prototype.showAlertMessage = function(type, message, delay) {\n\tvar self = this,\n\t\t\talertMessage = self.template.createAlertMessage(type, message);\n\t\n\tself.$alertsPanel.append($(alertMessage));\n\tsetTimeout(function() {\n\t\tself.$alertsPanel.children().eq(0).remove();\n\t}, delay);\n};\n\n/**\n * Appends the array of nodes returned by the comparison \n * to the <p> node element of each output pane \n * and shows the output panel.\n * @function\n * @param {Array} nodes - the array of nodes returned by the comparison\n */\nView.prototype.showSimilarities = function(nodes) {\n\tvar self = this,\n\t\t\tnLength = nodes.length;\n\t\t\n\tfor (var i = 0; i < nLength; i++) {\n\t\tvar $p = $('<p>').append(nodes[i]);\n\t\tself.$outputTextContainers.eq(i).html($p);\n\t}\n\t\n\tself._toggleOutputPanel('show');\n\tsetTimeout(function() {\n\t\tself._toggleInputPanel('hide');\n\t}, 100);\n\t\n\tself.toggleWaitingCursor('hide');\n};\n\n/**\n * Enables/disables the compare button\n * depending on the event specified.\n * @function\n * @param {String} event - the name of the event\n */\nView.prototype.toggleCompareBtn = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'enable':\n\t\t\tself.$compareBtn.prop('disabled', false);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'disable':\n\t\t\tself.$compareBtn.prop('disabled', true);\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Toggles the class \"has-error\", \n * which applies a red border around input node elements,\n * to prompt the user in case of erroneous input.\n * @function\n * @param {String} event     - the name of the event\n * @param {String} tabPaneId - the id of the tab pane\n */\nView.prototype.toggleErrorStatus = function(event, tabPaneId) {\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\t$(tabPaneId + ' .apply-error').addClass('has-error');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\t$(tabPaneId + ' .apply-error').removeClass('has-error');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Toggles the style of the cursor (from \"default\" to \"waiting\", and vice versa)\n * depending on the event specified.\n * @function\n * @param {String} event - the name of the event\n */\nView.prototype.toggleWaitingCursor = function(event) {\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tdocument.body.className = 'waiting';\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tdocument.body.className = '';\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Updates the value of a setting in the UI.\n * @function\n * @param {String}           id    - the id of the control element \n * @param {String}           type  - the type of the control element\n * @param {(Boolean|Number)} value - the value of the setting\n */\nView.prototype.updateUIOption = function(id, type, value) {\n\tswitch (type) {\n\t\tcase 'checkbox':\n\t\t\t$(id).prop('checked', value);\n\t\t\tbreak;\n\t\tcase 'select':\n\t\t\t$(id).val(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$(id).val(value);\n\t}\n};\n\n/**\n * Calculates the height of the output pane\n * so that it fits entirely in the window.\n * @function\n * @private\n */\nView.prototype._computeOutputPanelHeight = function() {\n\tvar self = this;\n\tvar bodyHeight = $('body').outerHeight(true);\n\tvar outputPos  = self.$outputPanel.offset().top;\n\tvar outputTopPadding = parseInt(self.$outputPanel.css('padding-top'), 10);\n\tvar elemPos    = self.$outputTexts.eq(0).offset().top;\n\tvar posOffset  = (elemPos - outputPos);\n\treturn bodyHeight - outputPos - (posOffset + outputTopPadding);\n};\n\n/**\n * Returns the id of a node element as a string (e.g. \"#id\").\n * @function\n * @param   {Object} target - the id of the node element\n * @returns {String}        - the string of the node element's id \n */\nView.prototype._getId = function(target) {\n\treturn '#' + $(target).attr('id');\n};\n\n/**\n * Returns the number contained in the id of a node element.\n * @function\n * @private\n * @param   {String} id - the id of the node element\n * @returns {Number}    - the number of the id\n */\nView.prototype._getIndex = function(id) {\n\tvar tokens = id.split('-'); \n\tvar idx = tokens[tokens.length - 1];\n\treturn parseInt(idx, 10) - 1;\n};\n\nView.prototype._toggleInputPanel = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'toggle':\n\t\t\t$('.btn-group.open').removeClass('open');\n\t\t\tself.$inputPanel.toggleClass('expanded');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tself.$inputPanel.removeClass('expanded');\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Shows/hides the output panel depending on the event specified.\n * @function\n * @private\n * @param {String} event - the name of the event\n */\nView.prototype._toggleOutputPanel = function(event) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tself.$outputPanel.removeClass('invisible');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\tself.$outputPanel.addClass('invisible');\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.'); \n\t}\n};\n\n/**\n * Shows/hides the \"PRINT OUTPUT\" dialog depending on the event specified.\n * @function\n * @private\n * @param {String} event  - the name of the event\n * @param {Object} target - the node element to be removed\n */\nView.prototype._togglePrintDialog = function(event, target) {\n\tvar self = this;\n\tswitch (event) {\n\t\tcase 'show':\n\t\t\tvar $printDialog = $(self.template.createPrintDialog(self.results.texts));\n\t\t\tself.$contentWrapper.append($printDialog);\n\t\t\t$printDialog.modal('show');\n\t\t\tbreak;\n\t\t\n\t\tcase 'hide':\n\t\t\t$(target).remove();\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tthrow new Error('Event type not valid.');\n\t}\n};\n\n/**\n * Updates the width of the alerts' panel.\n * @function\n * @private\n */\nView.prototype._updateAlertsPanelWidth = function() {\n\tvar self        = this,\n\t\t\tmarginLR      = 3 * 2,\n\t\t\tnavWidth      = $('nav').width(),\n\t\t\tnavLeftWidth  = $('nav .pull-left').outerWidth(),\n\t\t\tnavRightWidth = $('nav .pull-right').outerWidth(),\n\t\t\tmaxWidth      = navWidth - (navLeftWidth + navRightWidth + marginLR);\n\t\t\n\tself.$alertsPanel.css({\n\t\t'left'      : navLeftWidth + 'px',\n\t\t'max-width' : maxWidth + 'px'\n\t});\n};\n\n/**\n * Updates the height of each output pane.\n * @function\n * @private\n */\nView.prototype._updateOutputPanelHeight = function() {\n\tvar self = this,\n\t\t\th = self._computeOutputPanelHeight();\n\n\tself.$outputTexts.each(function() {\n\t\t$(this).css('height', h + 'px');\n\t});\n};\n\nmodule.exports = View;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {ScrollPosition}.\n * @constructor\n * @this  {ScrollPosition}\n * @param {Number} topPadding    - the top padding\n * @param {Number} bottomPadding - the bottom padding\n * @param {Number} yPosition     - the vertical position of the scroll bar\n */\nfunction ScrollPosition(topPadding, bottomPadding, yPosition) {\n\tthis.topPadding    = topPadding;\n\tthis.bottomPadding = bottomPadding;\n\tthis.yPosition     = yPosition;\n}\n\nmodule.exports = ScrollPosition;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $              = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar ScrollPosition = require('./scrollPosition.js');\n\n/**\n * Creates an instance of a {TargetMatch},\n * which hold information on the target match node element.\n * @constructor\n * @this  {TargetMatch}\n * @param {elem} elem - the source match node\n */\nfunction TargetMatch(elem) {\n\tthis.$srcElem             = $(elem);\n\tthis.$srcParent           = $(this.$srcElem.parent().parent().parent());\n\t\n\tthis.$elem                = $(this.$srcElem.attr('href'));\n\tthis.$wrapper             = $(this.$elem.parent());\n\tthis.$container           = $(this.$wrapper.parent());\n\tthis.$parent              = $(this.$container.parent());\n\t\n\tthis.parentHeight         = this.$parent[0].getBoundingClientRect().height;\n\tthis.containerTBPadding   = parseInt(this.$container.css('padding-top'), 10) + parseInt(this.$container.css('padding-bottom'), 10);\n\tthis.wrapperTopPadding    = parseFloat(this.$wrapper.css('padding-top'));\n\tthis.wrapperBottomPadding = parseFloat(this.$wrapper.css('padding-bottom'));\n}\n\n/**\n * Returns the new scroll position of the target match node.\n * @function\n * @returns {ScrollPosition} - the new scroll position\n */\nTargetMatch.prototype.getScrollPosition = function() {\n\tvar self                 = this,\n\t    wrapperBottom        = self.$wrapper.outerHeight(true) + self.containerTBPadding,\n\t    wrapperTopPadding    = self.wrapperTopPadding,\n\t    wrapperBottomPadding = self.wrapperBottomPadding,\n\t    // Calculate difference on the y axis (relative to parent element)\n\t    yPosDiff             = (self.$srcElem.offset().top - self.$srcParent.offset().top) - (self.$elem.offset().top - self.$parent.offset().top);\n\t\n\t// Remove top padding\n\tif (wrapperTopPadding > 0) {\n\t\tyPosDiff += wrapperTopPadding;\n\t\twrapperBottom -= wrapperTopPadding;\n\t\twrapperTopPadding = 0;\n\t}\n\t\n\t// Remove bottom padding\n\tif (wrapperBottomPadding > 0) {\n\t\twrapperBottom -= wrapperBottomPadding;\n\t\twrapperBottomPadding = 0;\n\t}\n\t\n\t// Compute new scroll position\n\tvar yScrollPos = self.$parent.scrollTop() - yPosDiff; \n\t\n\t// Add bottom padding, if needed\n\tif (yScrollPos > (wrapperBottom - self.parentHeight)) {\n\t\tvar bottomOffset = (yScrollPos + self.parentHeight) - (wrapperBottom);\n\t\twrapperBottomPadding = Math.abs(bottomOffset);\n\t}\n\t\n\t// Add top padding, if needed\n\tif (yScrollPos < 0) {\n\t\tvar topOffset = yScrollPos;\n\t\twrapperTopPadding = Math.abs(topOffset);\n\t\tyScrollPos -= topOffset;\n\t}\n\t\n\treturn new ScrollPosition(wrapperTopPadding, wrapperBottomPadding, yScrollPos);\n};\n\n/**\n * Animates scrolling to the new position.\n * @function\n * @param {ScrollPosition} scrollPosition - the new scroll position\n */\nTargetMatch.prototype.scroll = function(scrollPosition) {\n\tvar self = this;\n\t\n\tself.$wrapper.animate({\n\t\t'padding-top'    : scrollPosition.topPadding,\n\t\t'padding-bottom' : scrollPosition.bottomPadding,\n\t}, 700);\n\t\n\tself.$parent.animate({\n\t\t'scrollTop'      : scrollPosition.yPosition,\n\t}, 700);\n\t\n};\n\nmodule.exports = TargetMatch;","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $     = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar JSZip = (typeof window !== \"undefined\" ? window['JSZip'] : typeof global !== \"undefined\" ? global['JSZip'] : null);\n\n/**\n * Creates an instance of a {FileInputReader},\n * which parses and extracts the text contents of the DOCX, ODT and TXT files.\n * @constructor\n * @this  {FileInputReader}\n * @param {File}    file            - the file selected by the user\n * @param {Boolean} ignoreFootnotes - the option for including/excluding \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe document's footnotes from parsing\n */\nfunction FileInputReader(file, ignoreFootnotes) {\n\tthis.file            = file;\n\tthis.ignoreFootnotes = ignoreFootnotes;\n}\n\n/**\n * Returns a promise that handles the file reading.\n * When resolved, the contents of the file are returned as a string. \n * @function\n * @param   {Function} loadingStarted - the callback function \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  for the onloadstart event\n * @returns {Promise} \n */\nFileInputReader.prototype.readFileInput = function(loadingStarted) {\n\tvar self     = this,\n\t\t\tfile     = self.file,\n\t\t\tfileType = self._getFileType(),\n\t\t\tdeferred = $.Deferred(),\n\t\t\tfr       = new FileReader();\n\t\n\tfr.onerror = function(e) {\n\t\tvar error = e.target.error;\n\t\tswitch (error.code) {\n\t\t\tcase error.NOT_FOUND_ERR:\n\t\t\t\tdeferred.reject('File not found!');\n\t\t\t\tbreak;\n\t\t\tcase error.NOT_READABLE_ERR:\n\t\t\t\tdeferred.reject('File not readable.');\n\t\t\t\tbreak;\n\t\t\tcase error.ABORT_ERR:\n\t\t\t\tdeferred.reject('File reading aborted.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdeferred.reject('An error occurred while reading this file.');\n\t\t}\n\t};\n\t\n\tfr.onloadstart = loadingStarted;\n\t\n\tswitch (fileType) {\n\t\tcase 'docx':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar docxText = self._readDOCX(e.target.result);\n\t\t\t\t\n\t\t\t\tif (docxText) {\n\t\t\t\t\tif (/\\S/.test(docxText)) {\n\t\t\t\t\t\tdeferred.resolve(docxText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected DOCX file is empty.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject('The selected file is not a valid DOCX file.');\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsArrayBuffer(file);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'odt':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar odtText = self._readODT(e.target.result);\n\t\t\t\t\n\t\t\t\tif (odtText) {\n\t\t\t\t\tif (/\\S/.test(odtText)) {\n\t\t\t\t\t\tdeferred.resolve(odtText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected ODT file is empty.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject('The selected file is not a valid ODT file.');\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsArrayBuffer(file);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 'txt':\n\t\t\tfr.onload = function(e) {\n\t\t\t\tvar txtText = e.target.result;\n\t\t\t\t\n\t\t\t\tif (txtText) {\n\t\t\t\t\tif (/\\S/.test(txtText)) {\n\t\t\t\t\t\t// Mac uses carriage return, which is not processed correctly\n\t\t\t\t\t\t// Replace each carriage return, not followed by a line feed\n\t\t\t\t\t\t// with a line feed\n\t\t\t\t\t\tvar crCleanedText = txtText.replace(/\\r(?!\\n)/g, '\\n');\n\t\t\t\t\t\tdeferred.resolve(crCleanedText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.reject('The selected TXT file is empty.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfr.readAsText(file);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tdeferred.reject('File type not supported.');\n\t}\n\t\n\treturn deferred.promise();\n};\n\n/**\n * Traverses recursively all children starting from the top XML node,\n * irrespective of how deep the nesting is.\n * Returns their text contents as a string.\n * @function\n * @private\n * @param   {Object} node       - the top XML node element\n * @param   {String} tSelector  - the selector for text elements\n * @param   {String} brSelector - the selector for soft line breaks\n * @returns {String}            - the text content of the node\n */\nFileInputReader.prototype._extractTextFromNode = function(node, tSelector, brSelector) {\n\tvar self = this,\n\t\t\t// Paragraph selectors for both DOCX and ODT, \n\t\t\t// supported both by Chrome and other browsers\n\t\t\t// Chrome uses different selectors \n\t\t\tdelimeters = {\n\t\t\t\t'w:p'    : '\\n',\n\t\t\t\t'text:p' : '\\n',\n\t\t\t\t'p'      : '\\n'\n\t\t\t},\n\t\t\tdelimeter = delimeters[node.nodeName] || '',\n\t\t\tstr  = '';\n\t\t\n\tif (node.hasChildNodes()) {\n\t\tvar child = node.firstChild;\n\t\t\n\t\twhile (child) {\n\t\t\t// These selectors apply only to the footnotes of ODT files\n\t\t\t// Footnotes should appear all together at the end of the extracted text \n\t\t\t// and not inside the text at the point where the reference is.\n\t\t\tif (child.nodeName === 'text:note' || child.nodeName === 'note') {\n\t\t\t\tchild = child.nextSibling;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (child.nodeName === tSelector) {\n\t\t\t\tstr += child.textContent;\n\t\t\t} else if (child.nodeName === brSelector) {\n\t\t\t\tstr += '\\n';\n\t\t\t} \n\t\t\telse {\n\t\t\t\tstr += self._extractTextFromNode(child, tSelector, brSelector);\n\t\t\t}\n\t\t\t\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\t\n\treturn str + delimeter;\n};\n\n/**\n * Returns the type of file depending on the file's extension.\n * @function\n * @private\n * @param   {Object} file - the file selected by the user\n * @returns {String}      - the type of file\n */\nFileInputReader.prototype._getFileType = function() {\n\tvar self = this,\n\t\t\tfile = self.file;\n\t\n\tif (/docx$/i.test(file.name)) {\n\t\treturn 'docx';\n\t}\n\t\n\tif (/odt$/i.test(file.name)) {\n\t\treturn 'odt';\n\t}\n\t\n\tif (/txt$/i.test(file.name)) {\n\t\treturn 'txt';\n\t}\n\t\n\treturn undefined;\n};\n\n/**\n * Returns the contents of all XML nodes as a string.\n * \n * @function\n * @private\n * @param   {Object[]} nodes    - the array of XML nodes\n * @param   {String} tSelector  - the selector for text elements\n * @param   {String} brSelector - the selector for soft line breaks\n * @returns {String}            - the text content of all XML nodes\n */\nFileInputReader.prototype._getTextContent = function(nodes, tSelector, brSelector) {\n\tvar self    = this,\n\t\t\tnLength = nodes.length,\n\t\t\ttextContent;\n\t\n\tfor (var i = 0; i < nLength; i++) {\n\t\tvar node = nodes[i];\n\t\tvar nodeContent = self._extractTextFromNode(node, tSelector, brSelector);\n\t\ttextContent = [textContent, nodeContent].join('');\n\t}\n\t\n\treturn textContent;\n};\n\n/**\n * Returns the contents of the DOCX file as a string.\n * @function\n * @private\n * @param   {Object} fileContents - the contents of the file object\n * @returns {String}              - the text of the DOCX file\n */\nFileInputReader.prototype._readDOCX = function(fileContents) {\n\tvar self = this,\n\t\t\tdocument,\n\t\t\tfootnotes  = '',\n\t\t\txmlDoc,\n\t\t\ttSelector  = 'w:t',\n\t\t\tbrSelector = 'w:br',\n\t\t\tzip;\n\n\t// Unzip the file\n\ttry {\n\t\tzip = new JSZip(fileContents);\n\t\n\t\t// Read the main text of the DOCX file\n\t\tvar file = zip.files['word/document.xml'];\n\t\t\t\n\t\tif (file) {\n\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\tvar pNodes = $(xmlDoc).find('w\\\\:body, body').children();\n\t\t\tdocument = self._getTextContent(pNodes, tSelector, brSelector);\n\t\t}\n\t\t\n\t\t// Read footnotes/endnotes\n\t\tif (!self.ignoreFootnotes) {\n\t\t\t// Read footnotes\n\t\t\tfile = zip.files['word/footnotes.xml'];\n\t\t\tif (file) {\n\t\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\t\tvar fNodes = $(xmlDoc).find('w\\\\:footnotes, footnotes').children('w\\\\:footnote:not([w\\\\:type]), footnote:not([type])');\n\t\t\t\tvar fNodesText = self._getTextContent(fNodes, tSelector, brSelector);\n\t\t\t\tif (fNodesText) {\n\t\t\t\t\tfootnotes = [footnotes, fNodesText].join('');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Read endnotes\n\t\t\tfile = zip.files['word/endnotes.xml'];\n\t\t\tif (file) {\n\t\t\t\txmlDoc = $.parseXML(file.asText());\n\t\t\t\tvar eNodes = $(xmlDoc).find('w\\\\:endnotes, endnotes').children('w\\\\:endnote:not([w\\\\:type]), endnote:not([type])');\n\t\t\t\tvar eNodesText = self._getTextContent(eNodes, tSelector, brSelector);\n\t\t\t\tif (eNodesText) {\n\t\t\t\t\tfootnotes = [footnotes, eNodesText].join('');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (footnotes && footnotes.length) {\n\t\t\t\tdocument = [document, 'FOOTNOTES', footnotes].join('\\n'); \n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t\n\t}\n\t\n\treturn document;\n};\n\n/**\n * Returns the contents of the ODT file as a string.\n * @function\n * @private\n * @param   {Object} fileContents - the contents of the file object\n * @returns {String}              - the text of the ODT file\n */\nFileInputReader.prototype._readODT = function(fileContents) {\n\tvar self = this,\n\t\t\tdocument, \n\t\t\ttSelector  = '#text', \n\t\t\tbrSelector = 'text:line-break',\n\t\t\tzip;\n\t\n\t// Unzip the file\n\ttry {\n\t\tzip = new JSZip(fileContents);\n\n\t\t// Read the main text, as well as the footnotes/endnotes of the ODT file\n\t\tvar file = zip.files['content.xml'];\n\t\t\n\t\tif (file) {\n\t\t\tvar xmlDoc = $.parseXML(file.asText());\n\t\t\tvar pNodes = $(xmlDoc).find('office\\\\:body, body').children();\n\t\t\tdocument = self._getTextContent(pNodes, tSelector, brSelector);\n\t\t\t\n\t\t\tif (!self.ignoreFootnotes) {\n\t\t\t\tvar fNodes = $(pNodes).find('text\\\\:note-body, note-body');\n\t\t\t\tvar footnotes = self._getTextContent(fNodes, tSelector, brSelector);\n\t\t\t\t\n\t\t\t\tif (footnotes && footnotes.length) {\n\t\t\t\t\tdocument = [document, 'FOOTNOTES', footnotes].join('\\n'); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t\n\t}\n\t\n\treturn document;\n};\n\nmodule.exports = FileInputReader;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $       = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar XRegExp = (typeof window !== \"undefined\" ? window['XRegExp'] : typeof global !== \"undefined\" ? global['XRegExp'] : null);\n\n/**\n * Creates an instance of a {TextInputReader},\n * which parses and extracts the text contents of the HTML text input.\n * @constructor\n * @this {TextInputReader}\n */\nfunction TextInputReader() {\n}\n\n/**\n * Returns a promise that handles the HTML input reading.\n * When resolved, the contents of the HTML text\n * are returned as a string. \n * @function\n * @param   {String} text - the HTML text input\n * @returns {Promise}\n */\nTextInputReader.prototype.readTextInput = function(text) {\n\tvar self     = this,\n\t\t\tdeferred = $.Deferred();\n\t\t\n\tvar cleanedText = '';\n\tvar div = document.createElement('div');\n\tdiv.innerHTML = text;\n\n\tvar textNode = self._extractTextFromNode(div);\n\t// If is not empty or not contains only white spaces\n\tif (textNode.length && /\\S/.test(textNode)) {\n\t\tcleanedText = [cleanedText, textNode].join('');\n\t\t// Remove multiple white spaces\n\t\tcleanedText = cleanedText.replace(/\\n[ \\t\\v]*/g, '\\n');\n\t\t// Remove multiple newlines\n\t\tcleanedText = cleanedText.replace(/\\n{3,}/g, '\\n\\n');\n\t\t\n\t\t// Resolve\n\t\tdeferred.resolve(cleanedText);\n\t} else {\n\t\t// Reject\n\t\tdeferred.reject('HTML input has no valid text contents.');\n\t}\n\t\t\n\treturn deferred.promise();\n};\n\n/**\n * Traverses recursively all child nodes, \n * irrespective of how deep the nesting is.\n * Returns the HTML text contents as a string.\n * @function\n * @private\n * @param   {Object} node - the parent HTML node element\n * @returns {String}      - the text content of the HTML string\n */\nTextInputReader.prototype._extractTextFromNode = function(node) {\n\tvar self = this,\n\t\t\t// Match any letter\n\t\t\tletterRegex = XRegExp('^\\\\pL+$'),\n\t\t\tstr = '';\n\t\n\t// Returns whether a node should be skipped\n\tvar isValidNode = function(nodeName) {\n\t\tvar skipNodes       = ['IFRAME', 'NOSCRIPT', 'SCRIPT', 'STYLE'],\n\t\t\t\tskipNodesLength = skipNodes.length;\n\t\t\t\n\t\tfor (var i = 0; i < skipNodesLength; i++) {\n\t\t\tif (nodeName === skipNodes[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true; \n\t};\n\t\n\tif (isValidNode(node.nodeName) && node.hasChildNodes()) {\n\t\tvar child = node.firstChild;\n\t\t\n\t\twhile (child) {\n\t\t\t// If text node\n\t\t\tif (child.nodeType === 3) {\n\t\t\t\tvar content = child.textContent;\n\t\t\t\tif (content.length) {\n\t\t\t\t\tstr += content;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar extractedContent = self._extractTextFromNode(child);\n\t\t\t\t// Add a space between text nodes that are not separated \n\t\t\t\t// by a space or newline (e.g. as in lists)\n\t\t\t\tif (letterRegex.test(str[str.length - 1]) && letterRegex.test(extractedContent[0])) {\n\t\t\t\t\tstr += ' ';\n\t\t\t\t}\n\t\t\t\tstr += extractedContent;\n\t\t\t}\n\t\t\t\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\t\n\treturn str;\n};\n\nmodule.exports = TextInputReader;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $   = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar App = require('./app/app.js');\n\n// Main execution entry point\n$(window).load(function() {\n\tsetTimeout(function() {\n\t\t$(\".loader\").addClass('shrinked');\n\t\tvar app = new App('simtexter');\n\t}, 700);\n});\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Records a match found in the source and the target text.\n * @constructor\n * @this  {Match}\n * @param {Number} srcTxtIdx     - the index of the source text \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.texts[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is found\n * @param {Number} srcTkBeginPos - the index of the source text's token \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.tokens[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t starts \n * @param {Number} trgTxtIdx     - the index of the target text\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.texts[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is found\n * @param {Number} trgTkBeginPos - the index of the target text's token \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in {SimTexter.tokens[]}, where the match \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t starts\n * @param {Number} matchLength   - the length of the match \n */\nfunction Match(srcTxtIdx, srcTkBeginPos, trgTxtIdx, trgTkBeginPos, matchLength) {\n\tthis.srcTxtIdx     = srcTxtIdx;\n\tthis.srcTkBeginPos = srcTkBeginPos;\n\tthis.trgTxtIdx     = trgTxtIdx;\n\tthis.trgTkBeginPos = trgTkBeginPos;\n\tthis.matchLength   = matchLength;\n}\n\nmodule.exports = Match;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Records a match found in a text.\n * @constructor\n * @this  {MatchSegment}\n * @param {Number} txtIdx      - the index of the text in {SimTexter.texts[]},\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t where the match has been found\n * @param {Number} tkBeginPos  - the index of the token in {SimTexter.tokens[]},\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t where the match starts \n * @param {Number} matchLength - the length of the match\n */\nfunction MatchSegment(txtIdx, tkBeginPos, matchLength) {\n\tthis.txtIdx      = txtIdx;\n\tthis.tkBeginPos  = tkBeginPos;\n\tthis.matchLength = matchLength;\n\tthis.styleClass  = undefined;\n}\n\n/**\n * Returns the match's link node.\n * @function\n * @param {String}       text            - the text content of the node \n * @param {MatchSegment} trgMatchSegment - the target match segment\n * @returns                              - the match's link node\n */\nMatchSegment.prototype.createLinkNode = function(text, trgMatchSegment) {\n\tvar self = this,\n    \tmatchLink = document.createElement('a');\n    \t\n    matchLink.id          = [self.txtIdx + 1, '-', self.tkBeginPos].join('');\n    matchLink.className   = self.styleClass;\n    matchLink.href        = ['#', trgMatchSegment.txtIdx+1, '-', trgMatchSegment.tkBeginPos].join('');\n    matchLink.textContent = text;\n    return matchLink;\n};\n\n/**\n * Returns the index of the token in {SimTexter.tokens[]},\n * where the match ends.\n * @function\n * @returns {Number} - the last token position of the match (non-inclusive)\n */\nMatchSegment.prototype.getTkEndPosition = function() {\n\tvar self = this;\n\treturn self.tkBeginPos + self.matchLength;\n};\n\n/**\n * Returns the index of the character in the input string,\n * where the match starts.\n * @function\n * @returns {Number} - the first character of the match in the input string \n */\nMatchSegment.prototype.getTxtBeginPos = function(tokens) {\n\tvar self = this;\n    return tokens[self.tkBeginPos].txtBeginPos;\n};\n\n/**\n * Returns the index of the character in the input string,\n * where the match ends.\n * @function\n * @returns {Number} - the last character of the match in the input string \n */\nMatchSegment.prototype.getTxtEndPos = function(tokens) {\n\tvar self = this;\n    return tokens[self.tkBeginPos + self.matchLength - 1].txtEndPos;\n};\n\n/**\n * Sets the style class of the match segment.\n * @function\n * @param {(Number|String)} n - the style class to be applied\n */\nMatchSegment.prototype.setStyleClass = function(n) {\n\tvar self = this;\n\tif (typeof n === 'number') {\n\t\tself.styleClass = ['hl-', n % 10].join('');\n\t}\n\t\n\tif (typeof n === 'string') {\n\t\tself.styleClass = n;\n\t}\n};\n\nmodule.exports = MatchSegment;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\nvar $            = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar XRegExp      = (typeof window !== \"undefined\" ? window['XRegExp'] : typeof global !== \"undefined\" ? global['XRegExp'] : null);\nvar Match        = require('./match.js');\nvar MatchSegment = require('./matchSegment.js');\nvar Text         = require('./text.js');\nvar Token        = require('./token.js');\n\n/**\n * Creates an instance of {SimTexter}.\n * @constructor\n * @param {this}        SimTexter\n * @param {Object}      storage   - the object that holds the app's settings\n */\nfunction SimTexter(storage) {\n\tthis.ignoreLetterCase  = storage.getItemValueByKey('ignoreLetterCase');\n\tthis.ignoreNumbers     = storage.getItemValueByKey('ignoreNumbers');\n\tthis.ignorePunctuation = storage.getItemValueByKey('ignorePunctuation');\n\tthis.replaceUmlaut     = storage.getItemValueByKey('replaceUmlaut');\n\tthis.minMatchLength    = storage.getItemValueByKey('minMatchLength');\n\t\n\tthis.texts             = [];\n\tthis.tokens            = [new Token()];\n\tthis.uniqueMatches     = 0;\n}\n\n/**\n * Returns a promise that handles the comparison process.\n * When resolved, an array of nodes is returned,\n * which holds the text and the highlighted matches.\n * @function\n * @param {Array<InputText>} inputTexts - the array of {InputText} objects \n *                                        which hold information about the user \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\tinput\n */\nSimTexter.prototype.compare = function(inputTexts) {\n\tvar self     = this,\n\t\t\tdeferred = $.Deferred(),\n\t\t\tforwardReferences = [],\n\t\t\tsimilarities = [];\n\t\n\t\t// Read input (i.e. cleaning, tokenization)\n\t\tself._readInput(inputTexts, forwardReferences);\n\t\t// Get matches\n\t\tsimilarities = self._getSimilarities(0, 1, forwardReferences);\n\n\t\tif (similarities.length) {\n\t\t\t// Return input string as HTML nodes\n\t\t\tdeferred.resolve(self._getNodes(inputTexts, similarities));\n\t\t} else {\n\t\t\tdeferred.reject('No similarities found.');\n\t\t}\n\t\n\treturn deferred.promise();\n};\n\n/**\n * Applies a style class to each match segment\n * and removes duplicates from the array of matches.\n * Duplicates or overlapping segments can be traced,\n * if one observes the target {MatchSegment} objects \n * stored in the array matches.\n * Sorting of matches by target {MatchSegment}, \n * with its tkBeginPos in ascending order \n * and its matchLength in descending order,\n * makes removal of duplicates easy to handle.\n * The first {MatchSegment} with a given tkBeginPos\n * has the longest length. All others with the same tkBeginPos\n * have the same or a smaller length, and thus can be discarded.\n * @function\n * @private\n * @param   {Array} matches - the array that holds the match segments, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\tstored in pairs\n * @returns {Array}         - the array of unique matches\n */\nSimTexter.prototype._applyStyles = function(matches) {\n\tvar self = this;\n\t\n\t// Sort matches by target {MatchSegment},\n\t// where tkBeginPos in ascending order and matchLength in descending order\n\tvar sortedMatches = self._sortSimilarities(matches, 1);\n\tvar sortedMatchesLength = sortedMatches.length;\n\tvar styleClassCnt = 1;\n\t\n\t// Add first match in array of unique matches to have a starting point\n\tvar uniqueMatch = [sortedMatches[0][0], sortedMatches[0][1]];\n\tuniqueMatch[0].setStyleClass(0);\n\tuniqueMatch[1].setStyleClass(0);\n\tvar aUniqueMatches = [uniqueMatch];\n\n\t// For each match in sortedMatches[]\n\tfor (var i = 1; i < sortedMatchesLength; i++) {\n\t\tvar lastUniqueMatch = aUniqueMatches[aUniqueMatches.length - 1][1];\n\t\tvar match = sortedMatches[i][1];\n\t\t\n\t\t// If not duplicate\n\t\tif (lastUniqueMatch.tkBeginPos != match.tkBeginPos) {\n\t\t\t// if not overlapping\n\t\t\tif (lastUniqueMatch.getTkEndPosition() - 1 < match.tkBeginPos) {\n\t\t\t\tuniqueMatch = [sortedMatches[i][0], sortedMatches[i][1]];\n\t\t\t\tuniqueMatch[0].setStyleClass(styleClassCnt);\n\t\t\t\tuniqueMatch[1].setStyleClass(styleClassCnt);\n\t\t\t\taUniqueMatches.push(uniqueMatch);\n\t\t\t\tstyleClassCnt++;\n\t\t\t} else {\n\t\t\t\t// end-to-start overlapping\n\t\t\t\t// end of lastUniqueMatch overlaps with start of match\n\t\t\t\tif (lastUniqueMatch.getTkEndPosition() < match.getTkEndPosition()) {\n\t\t\t\t\tvar styleClass = ( /overlapping$/.test(lastUniqueMatch.styleClass) ) ? lastUniqueMatch.styleClass : lastUniqueMatch.styleClass + ' overlapping';\n\t\t\t\t\t// Overwrite the style of the last unique match segment \n\t\t\t\t\t// and change its length accordingly\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][0].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][1].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches[aUniqueMatches.length - 1][1].matchLength = match.tkBeginPos - lastUniqueMatch.tkBeginPos;\n\t\t\t\t\t\n\t\t\t\t\t// Add the new match segment\n\t\t\t\t\tuniqueMatch = [sortedMatches[i][0], sortedMatches[i][1]];\n\t\t\t\t\tuniqueMatch[0].setStyleClass(styleClass);\n\t\t\t\t\tuniqueMatch[1].setStyleClass(styleClass);\n\t\t\t\t\taUniqueMatches.push(uniqueMatch);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\n\tself.uniqueMatches = aUniqueMatches.length;\n\treturn aUniqueMatches;\n};\n\n/**\n * Returns a regular expression depending on the comparison options set.\n * Uses the XRegExp category patterns.\n * @function\n * @private\n * @returns {XRegExp} - the regular expression\n */\nSimTexter.prototype._buildRegex = function() {\n\tvar self = this,\n\t\t\t// XRegExp patterns\n\t\t\tNUMBERS     = '\\\\p{N}',\n\t\t\tPUNCTUATION = '\\\\p{P}',\t\t\n\t\t\tregex       = '';\n\t\n\tif (self.ignoreNumbers) {\n\t\tregex += NUMBERS;\n\t}\n\t\n\tif (self.ignorePunctuation) {\n\t\tregex += PUNCTUATION;\n\t}\n\t\t\n\treturn (regex.length > 0) ? XRegExp('[' + regex + ']', 'g') : undefined;\n};\n\n/**\n * Cleans the input string according to the comparison options set.\n * @function\n * @private\n * @param   {String} inputText - the input string\n * @returns {String}           - the cleaned input string\n */\nSimTexter.prototype._cleanInputText = function(inputText) {\n\tvar self = this,\n\t\t\ttext = inputText;\n\t\t\t\n\tvar langRegex = self._buildRegex();\n\t\n\tif (langRegex) {\n\t\ttext = inputText.replace(langRegex, ' ');\n\t}\n\t\n\tif (self.ignoreLetterCase) {\n\t\ttext = text.toLowerCase();\n\t}\n\t\n\treturn text;\n};\n\n/**\n * Returns a \"cleaned\" word, according to the comparison options set.\n * @function\n * @private\n * @param   {String} word - a sequence of characters, separated by one \n *                          or more white space characters (space, tab, newline)\n * @returns {String}      - the cleaned word\n */\nSimTexter.prototype._cleanWord = function(word) {\n\tvar self = this,\n\t\t\tumlautRules = {\n\t\t\t\t'ä': 'ae',\n\t\t  \t'ö': 'oe',\n\t\t  \t'ü': 'ue',\n\t\t  \t'ß': 'ss',\n\t\t  \t'æ': 'ae',\n\t\t  \t'œ': 'oe',\n\t\t  \t'Ä': 'AE',\n\t\t  \t'Ö': 'OE',\n\t\t  \t'Ü': 'UE',\n\t\t  \t'Æ': 'AE',\n\t\t  \t'Œ': 'OE'\n\t\t\t},\n\t\t\ttoken = word;\n\t\n\tif (self.replaceUmlaut) {\n\t\ttoken = word.replace(/ä|ö|ü|ß|æ|œ|Ä|Ö|Ü|Æ|Œ/g, function(key){\n\t\t\treturn umlautRules[key];\n\t\t});\n\t}\n\t\n\treturn token;\n};\n\n/**\n * Finds the longest common substring in the source and the target text\n * and returns the best match.\n * @function\n * @private\n * @param   {Number} srcTxtIdx     - the index of the source text in texts[] \n *                                   to be compared\n * @param   {Number} trgTxtIdx     - the index of the target text in texts[] \n *                                   to be compared\n * @param   {Number} srcTkBeginPos - the index of the token in tokens[] \n *                                   at which the comparison should start\n * @param   {Array}  frwReferences - the array of forward references\n * @returns {Match}                - the best match\n */\nSimTexter.prototype._getBestMatch = function(srcTxtIdx, trgTxtIdx, srcTkBeginPos, frwReferences) {\n\tvar self = this,\n\t\t\tbestMatch,\n\t\t\tbestMatchTkPos,\n\t\t\tbestMatchLength = 0,\n\t\t\tsrcTkPos = 0,\n\t\t\ttrgTkPos = 0;\n\t\n\tfor ( var tkPos = srcTkBeginPos;\n\t\t  (tkPos > 0) && (tkPos < self.tokens.length);\n\t\t  tkPos = frwReferences[tkPos]                   ) {\n\t\t\n\t\t// If token not within the range of the target text  \n\t\tif (tkPos < self.texts[trgTxtIdx].tkBeginPos) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvar minMatchLength = (bestMatchLength > 0) ? bestMatchLength + 1 : self.minMatchLength;\n\t\t\n\t\tsrcTkPos = srcTkBeginPos + minMatchLength - 1;\n\t\ttrgTkPos = tkPos + minMatchLength - 1;\n\t\t\n\t\t// Compare backwards\n\t\tif ( srcTkPos < self.texts[srcTxtIdx].tkEndPos &&\n\t\t\t\t trgTkPos < self.texts[trgTxtIdx].tkEndPos && \n\t\t\t \t (srcTkPos + minMatchLength) <= trgTkPos      ) { // check if they overlap\n\t\t\tvar cnt = minMatchLength;\n\t\t\t\n\t\t\twhile (cnt > 0 && self.tokens[srcTkPos].text === self.tokens[trgTkPos].text) {\n\t\t\t\tsrcTkPos--;\n\t\t\t\ttrgTkPos--;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Compare forwards\n\t\tvar newMatchLength = minMatchLength;\n\t\tsrcTkPos = srcTkBeginPos + minMatchLength;\n\t\ttrgTkPos = tkPos + minMatchLength;\n\t\t\n\t\twhile ( srcTkPos < self.texts[srcTxtIdx].tkEndPos &&\n\t\t\t\t\t\ttrgTkPos < self.texts[trgTxtIdx].tkEndPos && \n\t\t\t\t\t\t(srcTkPos + newMatchLength) < trgTkPos    && // check if they overlap\n\t\t\t\t\t\tself.tokens[srcTkPos].text === self.tokens[trgTkPos].text ) {\n\t\t\tsrcTkPos++;\n\t\t\ttrgTkPos++;\n\t\t\tnewMatchLength++;\n\t\t}\n\t\t\n\t\t// Record match\n\t\tif (newMatchLength >= self.minMatchLength && newMatchLength > bestMatchLength) {\n\t\t\tbestMatchLength = newMatchLength;\n\t\t\tbestMatchTkPos  = tkPos;\n\t\t\tbestMatch = new Match(srcTxtIdx, srcTkBeginPos, trgTxtIdx, bestMatchTkPos, bestMatchLength);\n\t\t}\n\t}\n\t\t\t\n\treturn bestMatch;\n};\n\n/**\n * Returns an array of HTML nodes, containing the whole text, \n * together with the hightlighted matches.\n * The text content of each node is retrieved by slicing the input text\n * at the first (txtBeginPos) and the last (txtEndPos) character position \n * of each match.\n * @function\n * @private\n * @param   {Array} inputTexts - the array of {InputText} objects, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t which hold information about each user input\n * @param   {Array} matches    - the array that holds the {MatchSegment} objects, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t stored in pairs\n * @returns {Array}            - the array of HTML nodes, \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t which holds the text and the highlighted matches\n */\nSimTexter.prototype._getNodes = function(inputTexts, matches) {\n\tvar self = this,\n\t\t\tiTextsLength = inputTexts.length,\n\t\t\tnodes = [];\n\t\n\tvar styledMatches = self._applyStyles(matches);\n\t\t\n\t// For each input text\n\tfor (var i = 0; i < iTextsLength; i++) {\n\t\tvar inputText = inputTexts[i].text,\n\t\t\t\tchIdx = 0,\n\t\t\t\tchIdxLast = chIdx,\n\t\t\t\tchEndPos = inputText.length,\n\t\t\t\tmIdx = 0,\n\t\t\t\ttrgIdxRef = (i == 0) ? (i + 1) : (i - 1);\n\t\t\t\tnodes[i] = [];\n\t\t\n\t\t// Sort array of similarities\n\t\tvar sortedMatches = self._sortSimilarities(styledMatches, i);\n\n\t\t// For each character position in input text\n\t\twhile (chIdx <= chEndPos) {\n\t\t\tif (sortedMatches.length && mIdx < sortedMatches.length) {\n\t\t\t\tvar match = sortedMatches[mIdx][i];\n\t\t\t\t// Get start character position of match segment\n\t\t\t\tvar mTxtBeginPos = match.getTxtBeginPos(self.tokens);\n\t\t\t\t// Get end character position of match segment\n\t\t\t\tvar mTxtEndPos = match.getTxtEndPos(self.tokens);\n\t\t\t\t\n\t\t\t\t// Create text node\n\t\t\t\tvar textNodeStr = inputText.slice(chIdxLast, mTxtBeginPos);\n\t\t\t\tvar textNode = document.createTextNode(textNodeStr);\n\t\t\t\tnodes[i].push(textNode);\n\t\t\t\t\n\t\t\t\t// Create link node for match segment\n\t\t\t\tvar linkNodeStr = inputText.slice(mTxtBeginPos, mTxtEndPos);\n\t\t\t\tvar linkNode = match.createLinkNode(linkNodeStr, sortedMatches[mIdx][trgIdxRef]);\n\t\t\t\tnodes[i].push(linkNode);\n\t\t\t\t\n\t\t\t\tmIdx++;\n\t\t\t\tchIdx = mTxtEndPos;\n\t\t\t\tchIdxLast = chIdx;\n\t\t\t} else {\n\t\t\t\tvar lastTextNodeStr = inputText.slice(chIdxLast, chEndPos);\n\t\t\t\tvar lastTextNode = document.createTextNode(lastTextNodeStr);\n\t\t\t\tnodes[i].push(lastTextNode);\n\t\t\t\tchIdx = chEndPos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchIdx++;\n\t\t}\n\t}\n\t\n\treturn nodes;\n};\n\n/**\n * Returns an array of matches,\n * where each match is an array of two {MatchSegment} objects, stored in pairs.\n * At index 0, the source {MatchSegment} object is stored,\n * and at index 1, the target {MatchSegment} object.\n * @function\n * @param   {Number} srcTxtIdx     - the index of the source {Text} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in texts[] to be compared\n * @param   {Number} trgTxtIdx     - the index of the target {Text} object \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t in texts[] to be compared\n * @param   {Array}  frwReferences - the array of forward references\n * @returns {Array}                - the array that holds the {MatchSegment} \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t objects, stored in pairs\n */\nSimTexter.prototype._getSimilarities = function(srcTxtIdx, trgTxtIdx, frwReferences) {\n\tvar self         = this,\n\t\t\tsimilarities = [],\n\t\t\tsrcTkPos     = self.texts[srcTxtIdx].tkBeginPos,\n\t\t\tsrcTkEndPos  = self.texts[srcTxtIdx].tkEndPos;\n\n\twhile ((srcTkPos + self.minMatchLength) <= srcTkEndPos) {\n\t\tvar bestMatch = self._getBestMatch(srcTxtIdx, trgTxtIdx, srcTkPos, frwReferences);\n\n\t\tif (bestMatch && bestMatch.matchLength > 0) {\n\t\t\tsimilarities.push([\n\t\t\t\t\tnew MatchSegment(bestMatch.srcTxtIdx, bestMatch.srcTkBeginPos, bestMatch.matchLength), \n\t\t\t\t\tnew MatchSegment(bestMatch.trgTxtIdx, bestMatch.trgTkBeginPos, bestMatch.matchLength)\n\t\t\t\t]);\n\t\t\tsrcTkPos += bestMatch.matchLength;\n\t\t} else {\n\t\t\tsrcTkPos++;\n\t\t}\n\t}\n\t\n\treturn similarities;\n};\n\n/**\n * Creates the forward reference table.\n * @function\n * @private\n * @param {Text}   text          - a {Text} object\n * @param {Array}  frwReferences - the array of forward references \n * @param {Object} mtsTags       - the hash table of minMatchLength \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sequence of tokens (MTS)\n */\nSimTexter.prototype._makeForwardReferences = function(text, frwReferences, mtsTags) {\n\tvar\tself      = this,\n\t\ttxtBeginPos = text.tkBeginPos,\n\t\ttxtEndPos   = text.tkEndPos;\n\t\t\n\t// For each token in tokens[]\n\tfor (var i = txtBeginPos; (i + self.minMatchLength - 1) < txtEndPos; i++) {\n\t\t// Concatenate tokens of minimum match length\n\t\tvar tag = self.tokens.slice(i, i + self.minMatchLength).map(function(token) {\n\t\t\treturn token.text;\n\t\t}).join('');\n\n\t\t// If hash table contains tag\n\t\tif (tag in mtsTags) {\n\t\t\t// Store current token position at index mtsTags[tag]\n\t\t\tfrwReferences[mtsTags[tag]] = i;\n\t\t}\n\t\t// Add tag to hash table and assign current token position to it\n\t\tmtsTags[tag] = i;\n\t}\n};\n\n/**\n * Reads the input string, and initializes texts[] and tokens[].\n * Creates also the forward reference table.\n * @function\n * @private\n * @param {Array} inputTexts    - the array of {InputText} objects\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  that hold information on the user input\n * @param {Array} frwReferences - the array of forward references\n */\nSimTexter.prototype._readInput = function(inputTexts, frwReferences) {\n\tvar self         = this,\n\t    mtsHashTable = {},\n\t    iLength      = inputTexts.length;\n\t\t\n\tfor (var i = 0; i < iLength; i++) {\n\t\tvar inputText = inputTexts[i];\n\t\t// Compute text's words\n\t\tvar nrOfWords = inputText.text.match(/[^\\s]+/g).length;\n\t\t// Initialize texts[]\n\t\tself.texts.push(new Text(inputText.mode, inputText.text.length, nrOfWords, inputText.fileName, self.tokens.length));\n\t\t// Initialize tokens[]\n\t\tself._tokenizeInput(inputText.text);\n\t\t// Update text's last token position\n\t\tself.texts[i].tkEndPos = self.tokens.length;\n\t\t// Create array of forward references\n\t\tself._makeForwardReferences(self.texts[i], frwReferences, mtsHashTable);\n\t}\n};\n\n/**\n * Sorts matches by source or target {MatchSegment},\n * depending on the idx value.\n * @function\n * @private\n * @param   {Array}  matches - the array of matches to be sorted\n * @param   {Number} idx     - the index of the array of \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t the {MatchSegment} objects\n * @returns {Array}          - the sorted array of matches\n */\nSimTexter.prototype._sortSimilarities = function(matches, idx) {\n\tvar sortedSims = matches.slice(0);\n\t\n\tsortedSims.sort(function(a, b) {\n\t\tvar pos = a[idx].tkBeginPos - b[idx].tkBeginPos;\n\t\tif (pos) {\n\t\t\treturn pos;\n\t\t}\n\t\treturn b[idx].matchLength - a[idx].matchLength;\n\t});\n\t\n\treturn sortedSims;\n};\n\n/**\n * Tokenizes the input string.\n * @param {Object} inputText - the input string to be tokenized\n */\nSimTexter.prototype._tokenizeInput = function(inputText) {\n\tvar self        = this,\n\t\t  wordRegex = /[^\\s]+/g,\n\t\t  match;\n\t\n\tvar cleanedText = self._cleanInputText(inputText);\n\t\t\n\twhile (match = wordRegex.exec(cleanedText)) {\n\t\tvar word = match[0];\n\t\tvar token = self._cleanWord(word);\n\t\t\n\t\tif (token.length > 0) {\n\t\t\tvar txtBeginPos = match.index;\n\t\t\tvar txtEndPos   = match.index + word.length;\n\t\t\t// Add token to tokens[]\n\t\t\tself.tokens.push(new Token(token, txtBeginPos, txtEndPos));\n\t\t}\n\t}\n};\n\nmodule.exports = SimTexter;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Text},\n * which holds information on the input string.\n * @constructor\n * @this  {Text}\n * @param {String} inputMode      - the mode of the input (i.e. 'File' \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tor 'Text')\n * @param {Number} nrOfCharacters - the total number of characters \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tof the input string\n * @param {Number} nrOfWords      - the total number of words \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tof the input string\n * @param {String} fileName       - the name of the file\n * @param {Number} tkBeginPos     - the index (inclusive) of the token\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin {SimTexter.tokens[]}, at which \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tthe input string starts \n * @param {Number} tkEndPos       - the index (non-inclusive) of the token\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  in {SimTexter.tokens[]}, at which \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tthe input string ends \n */\nfunction Text(inputMode, nrOfCharacters, nrOfWords, fileName, tkBeginPos, tkEndPos) {\n\tthis.inputMode      = inputMode;\n\tthis.fileName       = fileName;\n\tthis.tkBeginPos     = tkBeginPos     || 0;\n\tthis.tkEndPos       = tkEndPos       || 0;\n\tthis.nrOfCharacters = nrOfCharacters || 0;\n\tthis.nrOfWords      = nrOfWords      || 0;\n}\n\nmodule.exports = Text;\n","/* jshint undef:true, unused:true, node:true, browser:true */\n'use strict';\n\n/**\n * Creates an instance of a {Token}.\n * A {Token} records the starting and ending character position \n * of a word in the input string, to facilitate reconstruction of the input\n * during output of the comparison results.\n * A word is a sequence of characters, \n * separated by one or more whitespaces or newlines.\n * The text of the {Token} corresponds to the \"cleaned\" version of a word. \n * All characters, as defined by the comparison options set by the user,\n * are removed/replaced from the token's text.\n * @constructor\n * @this  {Token}\n * @param {String} text        - the text of the word after being \"cleaned\" \n *                               according to the comparison options \n *                               set by the user \n * @param {Number} txtBeginPos - the index of the word's first character \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (inclusive) in the input string\n * @param {Number} txtEndPos   - the index of the word's last character \n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (non-inclusive) in the input string\n */\nfunction Token(text, txtBeginPos, txtEndPos) {\n\tthis.text        = text        || '';\n\tthis.txtBeginPos = txtBeginPos || 0;\n\tthis.txtEndPos   = txtEndPos   || 0;\n}\n\nmodule.exports = Token;\n"],"sourceRoot":"/source/"}